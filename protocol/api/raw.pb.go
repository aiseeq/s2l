// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: raw.proto

package api

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DisplayType int32

const (
	DisplayType_nil         DisplayType = 0
	DisplayType_Visible     DisplayType = 1
	DisplayType_Snapshot    DisplayType = 2
	DisplayType_Hidden      DisplayType = 3
	DisplayType_Placeholder DisplayType = 4
)

var DisplayType_name = map[int32]string{
	0: "DisplayType_nil",
	1: "Visible",
	2: "Snapshot",
	3: "Hidden",
	4: "Placeholder",
}

var DisplayType_value = map[string]int32{
	"DisplayType_nil": 0,
	"Visible":         1,
	"Snapshot":        2,
	"Hidden":          3,
	"Placeholder":     4,
}

func (x DisplayType) String() string {
	return proto.EnumName(DisplayType_name, int32(x))
}

func (DisplayType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{0}
}

type Alliance int32

const (
	Alliance_nil     Alliance = 0
	Alliance_Self    Alliance = 1
	Alliance_Ally    Alliance = 2
	Alliance_Neutral Alliance = 3
	Alliance_Enemy   Alliance = 4
)

var Alliance_name = map[int32]string{
	0: "Alliance_nil",
	1: "Self",
	2: "Ally",
	3: "Neutral",
	4: "Enemy",
}

var Alliance_value = map[string]int32{
	"Alliance_nil": 0,
	"Self":         1,
	"Ally":         2,
	"Neutral":      3,
	"Enemy":        4,
}

func (x Alliance) String() string {
	return proto.EnumName(Alliance_name, int32(x))
}

func (Alliance) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{1}
}

type CloakState int32

const (
	CloakState_CloakedUnknown  CloakState = 0
	CloakState_Cloaked         CloakState = 1
	CloakState_CloakedDetected CloakState = 2
	CloakState_NotCloaked      CloakState = 3
	CloakState_CloakedAllied   CloakState = 4
)

var CloakState_name = map[int32]string{
	0: "CloakedUnknown",
	1: "Cloaked",
	2: "CloakedDetected",
	3: "NotCloaked",
	4: "CloakedAllied",
}

var CloakState_value = map[string]int32{
	"CloakedUnknown":  0,
	"Cloaked":         1,
	"CloakedDetected": 2,
	"NotCloaked":      3,
	"CloakedAllied":   4,
}

func (x CloakState) String() string {
	return proto.EnumName(CloakState_name, int32(x))
}

func (CloakState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{2}
}

type StartRaw struct {
	MapSize        *Size2DI    `protobuf:"bytes,1,opt,name=map_size,json=mapSize,proto3" json:"map_size,omitempty"`
	PathingGrid    *ImageData  `protobuf:"bytes,2,opt,name=pathing_grid,json=pathingGrid,proto3" json:"pathing_grid,omitempty"`
	TerrainHeight  *ImageData  `protobuf:"bytes,3,opt,name=terrain_height,json=terrainHeight,proto3" json:"terrain_height,omitempty"`
	PlacementGrid  *ImageData  `protobuf:"bytes,4,opt,name=placement_grid,json=placementGrid,proto3" json:"placement_grid,omitempty"`
	PlayableArea   *RectangleI `protobuf:"bytes,5,opt,name=playable_area,json=playableArea,proto3" json:"playable_area,omitempty"`
	StartLocations []*Point2D  `protobuf:"bytes,6,rep,name=start_locations,json=startLocations,proto3" json:"start_locations,omitempty"`
}

func (m *StartRaw) Reset()         { *m = StartRaw{} }
func (m *StartRaw) String() string { return proto.CompactTextString(m) }
func (*StartRaw) ProtoMessage()    {}
func (*StartRaw) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{0}
}
func (m *StartRaw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartRaw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartRaw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartRaw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartRaw.Merge(m, src)
}
func (m *StartRaw) XXX_Size() int {
	return m.Size()
}
func (m *StartRaw) XXX_DiscardUnknown() {
	xxx_messageInfo_StartRaw.DiscardUnknown(m)
}

var xxx_messageInfo_StartRaw proto.InternalMessageInfo

func (m *StartRaw) GetMapSize() *Size2DI {
	if m != nil {
		return m.MapSize
	}
	return nil
}

func (m *StartRaw) GetPathingGrid() *ImageData {
	if m != nil {
		return m.PathingGrid
	}
	return nil
}

func (m *StartRaw) GetTerrainHeight() *ImageData {
	if m != nil {
		return m.TerrainHeight
	}
	return nil
}

func (m *StartRaw) GetPlacementGrid() *ImageData {
	if m != nil {
		return m.PlacementGrid
	}
	return nil
}

func (m *StartRaw) GetPlayableArea() *RectangleI {
	if m != nil {
		return m.PlayableArea
	}
	return nil
}

func (m *StartRaw) GetStartLocations() []*Point2D {
	if m != nil {
		return m.StartLocations
	}
	return nil
}

type ObservationRaw struct {
	Player   *PlayerRaw   `protobuf:"bytes,1,opt,name=player,proto3" json:"player,omitempty"`
	Units    []*Unit      `protobuf:"bytes,2,rep,name=units,proto3" json:"units,omitempty"`
	MapState *MapState    `protobuf:"bytes,3,opt,name=map_state,json=mapState,proto3" json:"map_state,omitempty"`
	Event    *Event       `protobuf:"bytes,4,opt,name=event,proto3" json:"event,omitempty"`
	Effects  []*Effect    `protobuf:"bytes,5,rep,name=effects,proto3" json:"effects,omitempty"`
	Radar    []*RadarRing `protobuf:"bytes,6,rep,name=radar,proto3" json:"radar,omitempty"`
}

func (m *ObservationRaw) Reset()         { *m = ObservationRaw{} }
func (m *ObservationRaw) String() string { return proto.CompactTextString(m) }
func (*ObservationRaw) ProtoMessage()    {}
func (*ObservationRaw) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{1}
}
func (m *ObservationRaw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObservationRaw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObservationRaw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObservationRaw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObservationRaw.Merge(m, src)
}
func (m *ObservationRaw) XXX_Size() int {
	return m.Size()
}
func (m *ObservationRaw) XXX_DiscardUnknown() {
	xxx_messageInfo_ObservationRaw.DiscardUnknown(m)
}

var xxx_messageInfo_ObservationRaw proto.InternalMessageInfo

func (m *ObservationRaw) GetPlayer() *PlayerRaw {
	if m != nil {
		return m.Player
	}
	return nil
}

func (m *ObservationRaw) GetUnits() []*Unit {
	if m != nil {
		return m.Units
	}
	return nil
}

func (m *ObservationRaw) GetMapState() *MapState {
	if m != nil {
		return m.MapState
	}
	return nil
}

func (m *ObservationRaw) GetEvent() *Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *ObservationRaw) GetEffects() []*Effect {
	if m != nil {
		return m.Effects
	}
	return nil
}

func (m *ObservationRaw) GetRadar() []*RadarRing {
	if m != nil {
		return m.Radar
	}
	return nil
}

type RadarRing struct {
	Pos    *Point  `protobuf:"bytes,1,opt,name=pos,proto3" json:"pos,omitempty"`
	Radius float32 `protobuf:"fixed32,2,opt,name=radius,proto3" json:"radius,omitempty"`
}

func (m *RadarRing) Reset()         { *m = RadarRing{} }
func (m *RadarRing) String() string { return proto.CompactTextString(m) }
func (*RadarRing) ProtoMessage()    {}
func (*RadarRing) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{2}
}
func (m *RadarRing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RadarRing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RadarRing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RadarRing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadarRing.Merge(m, src)
}
func (m *RadarRing) XXX_Size() int {
	return m.Size()
}
func (m *RadarRing) XXX_DiscardUnknown() {
	xxx_messageInfo_RadarRing.DiscardUnknown(m)
}

var xxx_messageInfo_RadarRing proto.InternalMessageInfo

func (m *RadarRing) GetPos() *Point {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *RadarRing) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

type PowerSource struct {
	Pos    *Point  `protobuf:"bytes,1,opt,name=pos,proto3" json:"pos,omitempty"`
	Radius float32 `protobuf:"fixed32,2,opt,name=radius,proto3" json:"radius,omitempty"`
	Tag    UnitTag `protobuf:"varint,3,opt,name=tag,proto3,casttype=UnitTag" json:"tag,omitempty"`
}

func (m *PowerSource) Reset()         { *m = PowerSource{} }
func (m *PowerSource) String() string { return proto.CompactTextString(m) }
func (*PowerSource) ProtoMessage()    {}
func (*PowerSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{3}
}
func (m *PowerSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PowerSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PowerSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PowerSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PowerSource.Merge(m, src)
}
func (m *PowerSource) XXX_Size() int {
	return m.Size()
}
func (m *PowerSource) XXX_DiscardUnknown() {
	xxx_messageInfo_PowerSource.DiscardUnknown(m)
}

var xxx_messageInfo_PowerSource proto.InternalMessageInfo

func (m *PowerSource) GetPos() *Point {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *PowerSource) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *PowerSource) GetTag() UnitTag {
	if m != nil {
		return m.Tag
	}
	return 0
}

type PlayerRaw struct {
	PowerSources []*PowerSource `protobuf:"bytes,1,rep,name=power_sources,json=powerSources,proto3" json:"power_sources,omitempty"`
	Camera       *Point         `protobuf:"bytes,2,opt,name=camera,proto3" json:"camera,omitempty"`
	UpgradeIds   []UpgradeID    `protobuf:"varint,3,rep,packed,name=upgrade_ids,json=upgradeIds,proto3,casttype=UpgradeID" json:"upgrade_ids,omitempty"`
}

func (m *PlayerRaw) Reset()         { *m = PlayerRaw{} }
func (m *PlayerRaw) String() string { return proto.CompactTextString(m) }
func (*PlayerRaw) ProtoMessage()    {}
func (*PlayerRaw) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{4}
}
func (m *PlayerRaw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerRaw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerRaw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerRaw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerRaw.Merge(m, src)
}
func (m *PlayerRaw) XXX_Size() int {
	return m.Size()
}
func (m *PlayerRaw) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerRaw.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerRaw proto.InternalMessageInfo

func (m *PlayerRaw) GetPowerSources() []*PowerSource {
	if m != nil {
		return m.PowerSources
	}
	return nil
}

func (m *PlayerRaw) GetCamera() *Point {
	if m != nil {
		return m.Camera
	}
	return nil
}

func (m *PlayerRaw) GetUpgradeIds() []UpgradeID {
	if m != nil {
		return m.UpgradeIds
	}
	return nil
}

type UnitOrder struct {
	AbilityId AbilityID `protobuf:"varint,1,opt,name=ability_id,json=abilityId,proto3,casttype=AbilityID" json:"ability_id,omitempty"`
	// Types that are valid to be assigned to Target:
	//	*UnitOrder_TargetWorldSpacePos
	//	*UnitOrder_TargetUnitTag
	Target   isUnitOrder_Target `protobuf_oneof:"target"`
	Progress float32            `protobuf:"fixed32,4,opt,name=progress,proto3" json:"progress,omitempty"`
}

func (m *UnitOrder) Reset()         { *m = UnitOrder{} }
func (m *UnitOrder) String() string { return proto.CompactTextString(m) }
func (*UnitOrder) ProtoMessage()    {}
func (*UnitOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{5}
}
func (m *UnitOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnitOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnitOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnitOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnitOrder.Merge(m, src)
}
func (m *UnitOrder) XXX_Size() int {
	return m.Size()
}
func (m *UnitOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_UnitOrder.DiscardUnknown(m)
}

var xxx_messageInfo_UnitOrder proto.InternalMessageInfo

type isUnitOrder_Target interface {
	isUnitOrder_Target()
	MarshalTo([]byte) (int, error)
	Size() int
}

type UnitOrder_TargetWorldSpacePos struct {
	TargetWorldSpacePos *Point `protobuf:"bytes,2,opt,name=target_world_space_pos,json=targetWorldSpacePos,proto3,oneof" json:"target_world_space_pos,omitempty"`
}
type UnitOrder_TargetUnitTag struct {
	TargetUnitTag UnitTag `protobuf:"varint,3,opt,name=target_unit_tag,json=targetUnitTag,proto3,oneof,casttype=UnitTag" json:"target_unit_tag,omitempty"`
}

func (*UnitOrder_TargetWorldSpacePos) isUnitOrder_Target() {}
func (*UnitOrder_TargetUnitTag) isUnitOrder_Target()       {}

func (m *UnitOrder) GetTarget() isUnitOrder_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *UnitOrder) GetAbilityId() AbilityID {
	if m != nil {
		return m.AbilityId
	}
	return 0
}

func (m *UnitOrder) GetTargetWorldSpacePos() *Point {
	if x, ok := m.GetTarget().(*UnitOrder_TargetWorldSpacePos); ok {
		return x.TargetWorldSpacePos
	}
	return nil
}

func (m *UnitOrder) GetTargetUnitTag() UnitTag {
	if x, ok := m.GetTarget().(*UnitOrder_TargetUnitTag); ok {
		return x.TargetUnitTag
	}
	return 0
}

func (m *UnitOrder) GetProgress() float32 {
	if m != nil {
		return m.Progress
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UnitOrder) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UnitOrder_TargetWorldSpacePos)(nil),
		(*UnitOrder_TargetUnitTag)(nil),
	}
}

type PassengerUnit struct {
	Tag       UnitTag    `protobuf:"varint,1,opt,name=tag,proto3,casttype=UnitTag" json:"tag,omitempty"`
	Health    float32    `protobuf:"fixed32,2,opt,name=health,proto3" json:"health,omitempty"`
	HealthMax float32    `protobuf:"fixed32,3,opt,name=health_max,json=healthMax,proto3" json:"health_max,omitempty"`
	Shield    float32    `protobuf:"fixed32,4,opt,name=shield,proto3" json:"shield,omitempty"`
	ShieldMax float32    `protobuf:"fixed32,7,opt,name=shield_max,json=shieldMax,proto3" json:"shield_max,omitempty"`
	Energy    float32    `protobuf:"fixed32,5,opt,name=energy,proto3" json:"energy,omitempty"`
	EnergyMax float32    `protobuf:"fixed32,8,opt,name=energy_max,json=energyMax,proto3" json:"energy_max,omitempty"`
	UnitType  UnitTypeID `protobuf:"varint,6,opt,name=unit_type,json=unitType,proto3,casttype=UnitTypeID" json:"unit_type,omitempty"`
}

func (m *PassengerUnit) Reset()         { *m = PassengerUnit{} }
func (m *PassengerUnit) String() string { return proto.CompactTextString(m) }
func (*PassengerUnit) ProtoMessage()    {}
func (*PassengerUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{6}
}
func (m *PassengerUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PassengerUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PassengerUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PassengerUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PassengerUnit.Merge(m, src)
}
func (m *PassengerUnit) XXX_Size() int {
	return m.Size()
}
func (m *PassengerUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_PassengerUnit.DiscardUnknown(m)
}

var xxx_messageInfo_PassengerUnit proto.InternalMessageInfo

func (m *PassengerUnit) GetTag() UnitTag {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *PassengerUnit) GetHealth() float32 {
	if m != nil {
		return m.Health
	}
	return 0
}

func (m *PassengerUnit) GetHealthMax() float32 {
	if m != nil {
		return m.HealthMax
	}
	return 0
}

func (m *PassengerUnit) GetShield() float32 {
	if m != nil {
		return m.Shield
	}
	return 0
}

func (m *PassengerUnit) GetShieldMax() float32 {
	if m != nil {
		return m.ShieldMax
	}
	return 0
}

func (m *PassengerUnit) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *PassengerUnit) GetEnergyMax() float32 {
	if m != nil {
		return m.EnergyMax
	}
	return 0
}

func (m *PassengerUnit) GetUnitType() UnitTypeID {
	if m != nil {
		return m.UnitType
	}
	return 0
}

type RallyTarget struct {
	Point *Point `protobuf:"bytes,1,opt,name=point,proto3" json:"point,omitempty"`
	Tag   uint64 `protobuf:"varint,2,opt,name=tag,proto3" json:"tag,omitempty"`
}

func (m *RallyTarget) Reset()         { *m = RallyTarget{} }
func (m *RallyTarget) String() string { return proto.CompactTextString(m) }
func (*RallyTarget) ProtoMessage()    {}
func (*RallyTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{7}
}
func (m *RallyTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RallyTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RallyTarget.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RallyTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RallyTarget.Merge(m, src)
}
func (m *RallyTarget) XXX_Size() int {
	return m.Size()
}
func (m *RallyTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_RallyTarget.DiscardUnknown(m)
}

var xxx_messageInfo_RallyTarget proto.InternalMessageInfo

func (m *RallyTarget) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *RallyTarget) GetTag() uint64 {
	if m != nil {
		return m.Tag
	}
	return 0
}

type Unit struct {
	DisplayType        DisplayType         `protobuf:"varint,1,opt,name=display_type,json=displayType,proto3,enum=SC2APIProtocol.DisplayType" json:"display_type,omitempty"`
	Alliance           Alliance            `protobuf:"varint,2,opt,name=alliance,proto3,enum=SC2APIProtocol.Alliance" json:"alliance,omitempty"`
	Tag                UnitTag             `protobuf:"varint,3,opt,name=tag,proto3,casttype=UnitTag" json:"tag,omitempty"`
	UnitType           UnitTypeID          `protobuf:"varint,4,opt,name=unit_type,json=unitType,proto3,casttype=UnitTypeID" json:"unit_type,omitempty"`
	Owner              PlayerID            `protobuf:"varint,5,opt,name=owner,proto3,casttype=PlayerID" json:"owner,omitempty"`
	Pos                *Point              `protobuf:"bytes,6,opt,name=pos,proto3" json:"pos,omitempty"`
	Facing             float32             `protobuf:"fixed32,7,opt,name=facing,proto3" json:"facing,omitempty"`
	Radius             float32             `protobuf:"fixed32,8,opt,name=radius,proto3" json:"radius,omitempty"`
	BuildProgress      float32             `protobuf:"fixed32,9,opt,name=build_progress,json=buildProgress,proto3" json:"build_progress,omitempty"`
	Cloak              CloakState          `protobuf:"varint,10,opt,name=cloak,proto3,enum=SC2APIProtocol.CloakState" json:"cloak,omitempty"`
	BuffIds            []BuffID            `protobuf:"varint,27,rep,packed,name=buff_ids,json=buffIds,proto3,casttype=BuffID" json:"buff_ids,omitempty"`
	DetectRange        float32             `protobuf:"fixed32,31,opt,name=detect_range,json=detectRange,proto3" json:"detect_range,omitempty"`
	RadarRange         float32             `protobuf:"fixed32,32,opt,name=radar_range,json=radarRange,proto3" json:"radar_range,omitempty"`
	IsSelected         bool                `protobuf:"varint,11,opt,name=is_selected,json=isSelected,proto3" json:"is_selected,omitempty"`
	IsOnScreen         bool                `protobuf:"varint,12,opt,name=is_on_screen,json=isOnScreen,proto3" json:"is_on_screen,omitempty"`
	IsBlip             bool                `protobuf:"varint,13,opt,name=is_blip,json=isBlip,proto3" json:"is_blip,omitempty"`
	IsPowered          bool                `protobuf:"varint,35,opt,name=is_powered,json=isPowered,proto3" json:"is_powered,omitempty"`
	IsActive           bool                `protobuf:"varint,39,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	AttackUpgradeLevel int32               `protobuf:"varint,40,opt,name=attack_upgrade_level,json=attackUpgradeLevel,proto3" json:"attack_upgrade_level,omitempty"`
	ArmorUpgradeLevel  int32               `protobuf:"varint,41,opt,name=armor_upgrade_level,json=armorUpgradeLevel,proto3" json:"armor_upgrade_level,omitempty"`
	ShieldUpgradeLevel int32               `protobuf:"varint,42,opt,name=shield_upgrade_level,json=shieldUpgradeLevel,proto3" json:"shield_upgrade_level,omitempty"`
	Health             float32             `protobuf:"fixed32,14,opt,name=health,proto3" json:"health,omitempty"`
	HealthMax          float32             `protobuf:"fixed32,15,opt,name=health_max,json=healthMax,proto3" json:"health_max,omitempty"`
	Shield             float32             `protobuf:"fixed32,16,opt,name=shield,proto3" json:"shield,omitempty"`
	ShieldMax          float32             `protobuf:"fixed32,36,opt,name=shield_max,json=shieldMax,proto3" json:"shield_max,omitempty"`
	Energy             float32             `protobuf:"fixed32,17,opt,name=energy,proto3" json:"energy,omitempty"`
	EnergyMax          float32             `protobuf:"fixed32,37,opt,name=energy_max,json=energyMax,proto3" json:"energy_max,omitempty"`
	MineralContents    int32               `protobuf:"varint,18,opt,name=mineral_contents,json=mineralContents,proto3" json:"mineral_contents,omitempty"`
	VespeneContents    int32               `protobuf:"varint,19,opt,name=vespene_contents,json=vespeneContents,proto3" json:"vespene_contents,omitempty"`
	IsFlying           bool                `protobuf:"varint,20,opt,name=is_flying,json=isFlying,proto3" json:"is_flying,omitempty"`
	IsBurrowed         bool                `protobuf:"varint,21,opt,name=is_burrowed,json=isBurrowed,proto3" json:"is_burrowed,omitempty"`
	IsHallucination    bool                `protobuf:"varint,38,opt,name=is_hallucination,json=isHallucination,proto3" json:"is_hallucination,omitempty"`
	Orders             []*UnitOrder        `protobuf:"bytes,22,rep,name=orders,proto3" json:"orders,omitempty"`
	AddOnTag           UnitTag             `protobuf:"varint,23,opt,name=add_on_tag,json=addOnTag,proto3,casttype=UnitTag" json:"add_on_tag,omitempty"`
	Passengers         []*PassengerUnit    `protobuf:"bytes,24,rep,name=passengers,proto3" json:"passengers,omitempty"`
	CargoSpaceTaken    int32               `protobuf:"varint,25,opt,name=cargo_space_taken,json=cargoSpaceTaken,proto3" json:"cargo_space_taken,omitempty"`
	CargoSpaceMax      int32               `protobuf:"varint,26,opt,name=cargo_space_max,json=cargoSpaceMax,proto3" json:"cargo_space_max,omitempty"`
	AssignedHarvesters int32               `protobuf:"varint,28,opt,name=assigned_harvesters,json=assignedHarvesters,proto3" json:"assigned_harvesters,omitempty"`
	IdealHarvesters    int32               `protobuf:"varint,29,opt,name=ideal_harvesters,json=idealHarvesters,proto3" json:"ideal_harvesters,omitempty"`
	WeaponCooldown     float32             `protobuf:"fixed32,30,opt,name=weapon_cooldown,json=weaponCooldown,proto3" json:"weapon_cooldown,omitempty"`
	EngagedTargetTag   UnitTag             `protobuf:"varint,34,opt,name=engaged_target_tag,json=engagedTargetTag,proto3,casttype=UnitTag" json:"engaged_target_tag,omitempty"`
	BuffDurationRemain int32               `protobuf:"varint,43,opt,name=buff_duration_remain,json=buffDurationRemain,proto3" json:"buff_duration_remain,omitempty"`
	BuffDurationMax    int32               `protobuf:"varint,44,opt,name=buff_duration_max,json=buffDurationMax,proto3" json:"buff_duration_max,omitempty"`
	RallyTargets       []*RallyTarget      `protobuf:"bytes,45,rep,name=rally_targets,json=rallyTargets,proto3" json:"rally_targets,omitempty"`
	Actions            []*AvailableAbility `protobuf:"bytes,100,rep,name=actions,proto3" json:"actions,omitempty"`
}

func (m *Unit) Reset()         { *m = Unit{} }
func (m *Unit) String() string { return proto.CompactTextString(m) }
func (*Unit) ProtoMessage()    {}
func (*Unit) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{8}
}
func (m *Unit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Unit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Unit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Unit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Unit.Merge(m, src)
}
func (m *Unit) XXX_Size() int {
	return m.Size()
}
func (m *Unit) XXX_DiscardUnknown() {
	xxx_messageInfo_Unit.DiscardUnknown(m)
}

var xxx_messageInfo_Unit proto.InternalMessageInfo

func (m *Unit) GetDisplayType() DisplayType {
	if m != nil {
		return m.DisplayType
	}
	return DisplayType_nil
}

func (m *Unit) GetAlliance() Alliance {
	if m != nil {
		return m.Alliance
	}
	return Alliance_nil
}

func (m *Unit) GetTag() UnitTag {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *Unit) GetUnitType() UnitTypeID {
	if m != nil {
		return m.UnitType
	}
	return 0
}

func (m *Unit) GetOwner() PlayerID {
	if m != nil {
		return m.Owner
	}
	return 0
}

func (m *Unit) GetPos() *Point {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Unit) GetFacing() float32 {
	if m != nil {
		return m.Facing
	}
	return 0
}

func (m *Unit) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *Unit) GetBuildProgress() float32 {
	if m != nil {
		return m.BuildProgress
	}
	return 0
}

func (m *Unit) GetCloak() CloakState {
	if m != nil {
		return m.Cloak
	}
	return CloakState_CloakedUnknown
}

func (m *Unit) GetBuffIds() []BuffID {
	if m != nil {
		return m.BuffIds
	}
	return nil
}

func (m *Unit) GetDetectRange() float32 {
	if m != nil {
		return m.DetectRange
	}
	return 0
}

func (m *Unit) GetRadarRange() float32 {
	if m != nil {
		return m.RadarRange
	}
	return 0
}

func (m *Unit) GetIsSelected() bool {
	if m != nil {
		return m.IsSelected
	}
	return false
}

func (m *Unit) GetIsOnScreen() bool {
	if m != nil {
		return m.IsOnScreen
	}
	return false
}

func (m *Unit) GetIsBlip() bool {
	if m != nil {
		return m.IsBlip
	}
	return false
}

func (m *Unit) GetIsPowered() bool {
	if m != nil {
		return m.IsPowered
	}
	return false
}

func (m *Unit) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *Unit) GetAttackUpgradeLevel() int32 {
	if m != nil {
		return m.AttackUpgradeLevel
	}
	return 0
}

func (m *Unit) GetArmorUpgradeLevel() int32 {
	if m != nil {
		return m.ArmorUpgradeLevel
	}
	return 0
}

func (m *Unit) GetShieldUpgradeLevel() int32 {
	if m != nil {
		return m.ShieldUpgradeLevel
	}
	return 0
}

func (m *Unit) GetHealth() float32 {
	if m != nil {
		return m.Health
	}
	return 0
}

func (m *Unit) GetHealthMax() float32 {
	if m != nil {
		return m.HealthMax
	}
	return 0
}

func (m *Unit) GetShield() float32 {
	if m != nil {
		return m.Shield
	}
	return 0
}

func (m *Unit) GetShieldMax() float32 {
	if m != nil {
		return m.ShieldMax
	}
	return 0
}

func (m *Unit) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *Unit) GetEnergyMax() float32 {
	if m != nil {
		return m.EnergyMax
	}
	return 0
}

func (m *Unit) GetMineralContents() int32 {
	if m != nil {
		return m.MineralContents
	}
	return 0
}

func (m *Unit) GetVespeneContents() int32 {
	if m != nil {
		return m.VespeneContents
	}
	return 0
}

func (m *Unit) GetIsFlying() bool {
	if m != nil {
		return m.IsFlying
	}
	return false
}

func (m *Unit) GetIsBurrowed() bool {
	if m != nil {
		return m.IsBurrowed
	}
	return false
}

func (m *Unit) GetIsHallucination() bool {
	if m != nil {
		return m.IsHallucination
	}
	return false
}

func (m *Unit) GetOrders() []*UnitOrder {
	if m != nil {
		return m.Orders
	}
	return nil
}

func (m *Unit) GetAddOnTag() UnitTag {
	if m != nil {
		return m.AddOnTag
	}
	return 0
}

func (m *Unit) GetPassengers() []*PassengerUnit {
	if m != nil {
		return m.Passengers
	}
	return nil
}

func (m *Unit) GetCargoSpaceTaken() int32 {
	if m != nil {
		return m.CargoSpaceTaken
	}
	return 0
}

func (m *Unit) GetCargoSpaceMax() int32 {
	if m != nil {
		return m.CargoSpaceMax
	}
	return 0
}

func (m *Unit) GetAssignedHarvesters() int32 {
	if m != nil {
		return m.AssignedHarvesters
	}
	return 0
}

func (m *Unit) GetIdealHarvesters() int32 {
	if m != nil {
		return m.IdealHarvesters
	}
	return 0
}

func (m *Unit) GetWeaponCooldown() float32 {
	if m != nil {
		return m.WeaponCooldown
	}
	return 0
}

func (m *Unit) GetEngagedTargetTag() UnitTag {
	if m != nil {
		return m.EngagedTargetTag
	}
	return 0
}

func (m *Unit) GetBuffDurationRemain() int32 {
	if m != nil {
		return m.BuffDurationRemain
	}
	return 0
}

func (m *Unit) GetBuffDurationMax() int32 {
	if m != nil {
		return m.BuffDurationMax
	}
	return 0
}

func (m *Unit) GetRallyTargets() []*RallyTarget {
	if m != nil {
		return m.RallyTargets
	}
	return nil
}

func (m *Unit) GetActions() []*AvailableAbility {
	if m != nil {
		return m.Actions
	}
	return nil
}

type MapState struct {
	Visibility *ImageData `protobuf:"bytes,1,opt,name=visibility,proto3" json:"visibility,omitempty"`
	Creep      *ImageData `protobuf:"bytes,2,opt,name=creep,proto3" json:"creep,omitempty"`
}

func (m *MapState) Reset()         { *m = MapState{} }
func (m *MapState) String() string { return proto.CompactTextString(m) }
func (*MapState) ProtoMessage()    {}
func (*MapState) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{9}
}
func (m *MapState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MapState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MapState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MapState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapState.Merge(m, src)
}
func (m *MapState) XXX_Size() int {
	return m.Size()
}
func (m *MapState) XXX_DiscardUnknown() {
	xxx_messageInfo_MapState.DiscardUnknown(m)
}

var xxx_messageInfo_MapState proto.InternalMessageInfo

func (m *MapState) GetVisibility() *ImageData {
	if m != nil {
		return m.Visibility
	}
	return nil
}

func (m *MapState) GetCreep() *ImageData {
	if m != nil {
		return m.Creep
	}
	return nil
}

type Event struct {
	DeadUnits []UnitTag `protobuf:"varint,1,rep,packed,name=dead_units,json=deadUnits,proto3,casttype=UnitTag" json:"dead_units,omitempty"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{10}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetDeadUnits() []UnitTag {
	if m != nil {
		return m.DeadUnits
	}
	return nil
}

type Effect struct {
	EffectId EffectID   `protobuf:"varint,1,opt,name=effect_id,json=effectId,proto3,casttype=EffectID" json:"effect_id,omitempty"`
	Pos      []*Point2D `protobuf:"bytes,2,rep,name=pos,proto3" json:"pos,omitempty"`
	Alliance Alliance   `protobuf:"varint,3,opt,name=alliance,proto3,enum=SC2APIProtocol.Alliance" json:"alliance,omitempty"`
	Owner    int32      `protobuf:"varint,4,opt,name=owner,proto3" json:"owner,omitempty"`
	Radius   float32    `protobuf:"fixed32,5,opt,name=radius,proto3" json:"radius,omitempty"`
}

func (m *Effect) Reset()         { *m = Effect{} }
func (m *Effect) String() string { return proto.CompactTextString(m) }
func (*Effect) ProtoMessage()    {}
func (*Effect) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{11}
}
func (m *Effect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Effect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Effect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Effect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Effect.Merge(m, src)
}
func (m *Effect) XXX_Size() int {
	return m.Size()
}
func (m *Effect) XXX_DiscardUnknown() {
	xxx_messageInfo_Effect.DiscardUnknown(m)
}

var xxx_messageInfo_Effect proto.InternalMessageInfo

func (m *Effect) GetEffectId() EffectID {
	if m != nil {
		return m.EffectId
	}
	return 0
}

func (m *Effect) GetPos() []*Point2D {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Effect) GetAlliance() Alliance {
	if m != nil {
		return m.Alliance
	}
	return Alliance_nil
}

func (m *Effect) GetOwner() int32 {
	if m != nil {
		return m.Owner
	}
	return 0
}

func (m *Effect) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

type ActionRaw struct {
	// Types that are valid to be assigned to Action:
	//	*ActionRaw_UnitCommand
	//	*ActionRaw_CameraMove
	//	*ActionRaw_ToggleAutocast
	Action isActionRaw_Action `protobuf_oneof:"action"`
}

func (m *ActionRaw) Reset()         { *m = ActionRaw{} }
func (m *ActionRaw) String() string { return proto.CompactTextString(m) }
func (*ActionRaw) ProtoMessage()    {}
func (*ActionRaw) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{12}
}
func (m *ActionRaw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionRaw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionRaw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionRaw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionRaw.Merge(m, src)
}
func (m *ActionRaw) XXX_Size() int {
	return m.Size()
}
func (m *ActionRaw) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionRaw.DiscardUnknown(m)
}

var xxx_messageInfo_ActionRaw proto.InternalMessageInfo

type isActionRaw_Action interface {
	isActionRaw_Action()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ActionRaw_UnitCommand struct {
	UnitCommand *ActionRawUnitCommand `protobuf:"bytes,1,opt,name=unit_command,json=unitCommand,proto3,oneof" json:"unit_command,omitempty"`
}
type ActionRaw_CameraMove struct {
	CameraMove *ActionRawCameraMove `protobuf:"bytes,2,opt,name=camera_move,json=cameraMove,proto3,oneof" json:"camera_move,omitempty"`
}
type ActionRaw_ToggleAutocast struct {
	ToggleAutocast *ActionRawToggleAutocast `protobuf:"bytes,3,opt,name=toggle_autocast,json=toggleAutocast,proto3,oneof" json:"toggle_autocast,omitempty"`
}

func (*ActionRaw_UnitCommand) isActionRaw_Action()    {}
func (*ActionRaw_CameraMove) isActionRaw_Action()     {}
func (*ActionRaw_ToggleAutocast) isActionRaw_Action() {}

func (m *ActionRaw) GetAction() isActionRaw_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *ActionRaw) GetUnitCommand() *ActionRawUnitCommand {
	if x, ok := m.GetAction().(*ActionRaw_UnitCommand); ok {
		return x.UnitCommand
	}
	return nil
}

func (m *ActionRaw) GetCameraMove() *ActionRawCameraMove {
	if x, ok := m.GetAction().(*ActionRaw_CameraMove); ok {
		return x.CameraMove
	}
	return nil
}

func (m *ActionRaw) GetToggleAutocast() *ActionRawToggleAutocast {
	if x, ok := m.GetAction().(*ActionRaw_ToggleAutocast); ok {
		return x.ToggleAutocast
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ActionRaw) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ActionRaw_UnitCommand)(nil),
		(*ActionRaw_CameraMove)(nil),
		(*ActionRaw_ToggleAutocast)(nil),
	}
}

type ActionRawUnitCommand struct {
	AbilityId AbilityID `protobuf:"varint,1,opt,name=ability_id,json=abilityId,proto3,casttype=AbilityID" json:"ability_id,omitempty"`
	// Types that are valid to be assigned to Target:
	//	*ActionRawUnitCommand_TargetWorldSpacePos
	//	*ActionRawUnitCommand_TargetUnitTag
	Target       isActionRawUnitCommand_Target `protobuf_oneof:"target"`
	UnitTags     []UnitTag                     `protobuf:"varint,4,rep,packed,name=unit_tags,json=unitTags,proto3,casttype=UnitTag" json:"unit_tags,omitempty"`
	QueueCommand bool                          `protobuf:"varint,5,opt,name=queue_command,json=queueCommand,proto3" json:"queue_command,omitempty"`
}

func (m *ActionRawUnitCommand) Reset()         { *m = ActionRawUnitCommand{} }
func (m *ActionRawUnitCommand) String() string { return proto.CompactTextString(m) }
func (*ActionRawUnitCommand) ProtoMessage()    {}
func (*ActionRawUnitCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{13}
}
func (m *ActionRawUnitCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionRawUnitCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionRawUnitCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionRawUnitCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionRawUnitCommand.Merge(m, src)
}
func (m *ActionRawUnitCommand) XXX_Size() int {
	return m.Size()
}
func (m *ActionRawUnitCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionRawUnitCommand.DiscardUnknown(m)
}

var xxx_messageInfo_ActionRawUnitCommand proto.InternalMessageInfo

type isActionRawUnitCommand_Target interface {
	isActionRawUnitCommand_Target()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ActionRawUnitCommand_TargetWorldSpacePos struct {
	TargetWorldSpacePos *Point2D `protobuf:"bytes,2,opt,name=target_world_space_pos,json=targetWorldSpacePos,proto3,oneof" json:"target_world_space_pos,omitempty"`
}
type ActionRawUnitCommand_TargetUnitTag struct {
	TargetUnitTag UnitTag `protobuf:"varint,3,opt,name=target_unit_tag,json=targetUnitTag,proto3,oneof,casttype=UnitTag" json:"target_unit_tag,omitempty"`
}

func (*ActionRawUnitCommand_TargetWorldSpacePos) isActionRawUnitCommand_Target() {}
func (*ActionRawUnitCommand_TargetUnitTag) isActionRawUnitCommand_Target()       {}

func (m *ActionRawUnitCommand) GetTarget() isActionRawUnitCommand_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *ActionRawUnitCommand) GetAbilityId() AbilityID {
	if m != nil {
		return m.AbilityId
	}
	return 0
}

func (m *ActionRawUnitCommand) GetTargetWorldSpacePos() *Point2D {
	if x, ok := m.GetTarget().(*ActionRawUnitCommand_TargetWorldSpacePos); ok {
		return x.TargetWorldSpacePos
	}
	return nil
}

func (m *ActionRawUnitCommand) GetTargetUnitTag() UnitTag {
	if x, ok := m.GetTarget().(*ActionRawUnitCommand_TargetUnitTag); ok {
		return x.TargetUnitTag
	}
	return 0
}

func (m *ActionRawUnitCommand) GetUnitTags() []UnitTag {
	if m != nil {
		return m.UnitTags
	}
	return nil
}

func (m *ActionRawUnitCommand) GetQueueCommand() bool {
	if m != nil {
		return m.QueueCommand
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ActionRawUnitCommand) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ActionRawUnitCommand_TargetWorldSpacePos)(nil),
		(*ActionRawUnitCommand_TargetUnitTag)(nil),
	}
}

type ActionRawCameraMove struct {
	CenterWorldSpace *Point `protobuf:"bytes,1,opt,name=center_world_space,json=centerWorldSpace,proto3" json:"center_world_space,omitempty"`
}

func (m *ActionRawCameraMove) Reset()         { *m = ActionRawCameraMove{} }
func (m *ActionRawCameraMove) String() string { return proto.CompactTextString(m) }
func (*ActionRawCameraMove) ProtoMessage()    {}
func (*ActionRawCameraMove) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{14}
}
func (m *ActionRawCameraMove) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionRawCameraMove) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionRawCameraMove.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionRawCameraMove) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionRawCameraMove.Merge(m, src)
}
func (m *ActionRawCameraMove) XXX_Size() int {
	return m.Size()
}
func (m *ActionRawCameraMove) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionRawCameraMove.DiscardUnknown(m)
}

var xxx_messageInfo_ActionRawCameraMove proto.InternalMessageInfo

func (m *ActionRawCameraMove) GetCenterWorldSpace() *Point {
	if m != nil {
		return m.CenterWorldSpace
	}
	return nil
}

type ActionRawToggleAutocast struct {
	AbilityId AbilityID `protobuf:"varint,1,opt,name=ability_id,json=abilityId,proto3,casttype=AbilityID" json:"ability_id,omitempty"`
	UnitTags  []UnitTag `protobuf:"varint,2,rep,packed,name=unit_tags,json=unitTags,proto3,casttype=UnitTag" json:"unit_tags,omitempty"`
}

func (m *ActionRawToggleAutocast) Reset()         { *m = ActionRawToggleAutocast{} }
func (m *ActionRawToggleAutocast) String() string { return proto.CompactTextString(m) }
func (*ActionRawToggleAutocast) ProtoMessage()    {}
func (*ActionRawToggleAutocast) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b310728fa7f370e, []int{15}
}
func (m *ActionRawToggleAutocast) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionRawToggleAutocast) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionRawToggleAutocast.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionRawToggleAutocast) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionRawToggleAutocast.Merge(m, src)
}
func (m *ActionRawToggleAutocast) XXX_Size() int {
	return m.Size()
}
func (m *ActionRawToggleAutocast) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionRawToggleAutocast.DiscardUnknown(m)
}

var xxx_messageInfo_ActionRawToggleAutocast proto.InternalMessageInfo

func (m *ActionRawToggleAutocast) GetAbilityId() AbilityID {
	if m != nil {
		return m.AbilityId
	}
	return 0
}

func (m *ActionRawToggleAutocast) GetUnitTags() []UnitTag {
	if m != nil {
		return m.UnitTags
	}
	return nil
}

func init() {
	proto.RegisterEnum("SC2APIProtocol.DisplayType", DisplayType_name, DisplayType_value)
	proto.RegisterEnum("SC2APIProtocol.Alliance", Alliance_name, Alliance_value)
	proto.RegisterEnum("SC2APIProtocol.CloakState", CloakState_name, CloakState_value)
	proto.RegisterType((*StartRaw)(nil), "SC2APIProtocol.StartRaw")
	proto.RegisterType((*ObservationRaw)(nil), "SC2APIProtocol.ObservationRaw")
	proto.RegisterType((*RadarRing)(nil), "SC2APIProtocol.RadarRing")
	proto.RegisterType((*PowerSource)(nil), "SC2APIProtocol.PowerSource")
	proto.RegisterType((*PlayerRaw)(nil), "SC2APIProtocol.PlayerRaw")
	proto.RegisterType((*UnitOrder)(nil), "SC2APIProtocol.UnitOrder")
	proto.RegisterType((*PassengerUnit)(nil), "SC2APIProtocol.PassengerUnit")
	proto.RegisterType((*RallyTarget)(nil), "SC2APIProtocol.RallyTarget")
	proto.RegisterType((*Unit)(nil), "SC2APIProtocol.Unit")
	proto.RegisterType((*MapState)(nil), "SC2APIProtocol.MapState")
	proto.RegisterType((*Event)(nil), "SC2APIProtocol.Event")
	proto.RegisterType((*Effect)(nil), "SC2APIProtocol.Effect")
	proto.RegisterType((*ActionRaw)(nil), "SC2APIProtocol.ActionRaw")
	proto.RegisterType((*ActionRawUnitCommand)(nil), "SC2APIProtocol.ActionRawUnitCommand")
	proto.RegisterType((*ActionRawCameraMove)(nil), "SC2APIProtocol.ActionRawCameraMove")
	proto.RegisterType((*ActionRawToggleAutocast)(nil), "SC2APIProtocol.ActionRawToggleAutocast")
}

func init() { proto.RegisterFile("raw.proto", fileDescriptor_2b310728fa7f370e) }

var fileDescriptor_2b310728fa7f370e = []byte{
	// 2034 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4b, 0x73, 0x1b, 0xc7,
	0x11, 0x26, 0x00, 0x02, 0x04, 0x1a, 0x4f, 0x0d, 0x29, 0x69, 0x45, 0x59, 0x24, 0x03, 0x59, 0x96,
	0x44, 0xd9, 0x94, 0x22, 0x27, 0x07, 0xe7, 0x29, 0x3e, 0xec, 0x10, 0x55, 0x7a, 0x30, 0x43, 0x29,
	0xa9, 0xf2, 0x65, 0x6b, 0xb8, 0x3b, 0x5c, 0x4e, 0x69, 0x31, 0xbb, 0x9e, 0x59, 0x80, 0xa6, 0x4f,
	0xa9, 0xca, 0x2d, 0xa7, 0xfc, 0x81, 0xdc, 0x52, 0x39, 0xe5, 0x9c, 0x1f, 0x90, 0x53, 0x8e, 0x3e,
	0xe6, 0xa4, 0x4a, 0x49, 0xf9, 0x15, 0xaa, 0x1c, 0x52, 0x3d, 0x33, 0x0b, 0x80, 0x04, 0x09, 0x3a,
	0x15, 0xdf, 0xb6, 0xbb, 0xbf, 0x6f, 0x1e, 0xdd, 0x33, 0xdd, 0x3d, 0x0b, 0x35, 0xc5, 0x8e, 0x37,
	0x52, 0x95, 0x64, 0x09, 0x69, 0xed, 0x6f, 0x3f, 0xde, 0xdc, 0xeb, 0xed, 0xa1, 0x10, 0x24, 0xf1,
	0x32, 0x44, 0x49, 0x94, 0x58, 0xdb, 0x72, 0x23, 0x48, 0xfa, 0xfd, 0x44, 0x5a, 0xa9, 0xfb, 0xfb,
	0x12, 0x54, 0xf7, 0x33, 0xa6, 0x32, 0xca, 0x8e, 0xc9, 0x63, 0xa8, 0xf6, 0x59, 0xea, 0x6b, 0xf1,
	0x0d, 0xf7, 0x0a, 0x6b, 0x85, 0x7b, 0xf5, 0xc7, 0xd7, 0x37, 0x4e, 0x8f, 0xb4, 0xb1, 0x2f, 0xbe,
	0xe1, 0x8f, 0x77, 0x7a, 0x74, 0xa1, 0xcf, 0x52, 0xfc, 0x26, 0x3f, 0x83, 0x46, 0xca, 0xb2, 0x23,
	0x21, 0x23, 0x3f, 0x52, 0x22, 0xf4, 0x8a, 0x86, 0x77, 0xe3, 0x2c, 0xaf, 0xd7, 0x67, 0x11, 0xdf,
	0x61, 0x19, 0xa3, 0x75, 0x07, 0xff, 0x95, 0x12, 0x21, 0x79, 0x02, 0xad, 0x8c, 0x2b, 0xc5, 0x84,
	0xf4, 0x8f, 0xb8, 0x88, 0x8e, 0x32, 0xaf, 0x74, 0x19, 0xbf, 0xe9, 0x08, 0xbb, 0x06, 0x8f, 0x23,
	0xa4, 0x31, 0x0b, 0x78, 0x9f, 0xcb, 0xcc, 0xae, 0x60, 0xfe, 0xd2, 0x11, 0x46, 0x04, 0xb3, 0x86,
	0x5f, 0x02, 0x2a, 0x4e, 0xd8, 0x41, 0xcc, 0x7d, 0xa6, 0x38, 0xf3, 0xca, 0x66, 0x80, 0xe5, 0xb3,
	0x03, 0x50, 0x1e, 0x64, 0x4c, 0x46, 0x31, 0xef, 0xd1, 0x46, 0x4e, 0xd8, 0x54, 0x9c, 0x91, 0x27,
	0xd0, 0xd6, 0xe8, 0x42, 0x3f, 0x4e, 0x02, 0x96, 0x89, 0x44, 0x6a, 0xaf, 0xb2, 0x56, 0x3a, 0xcf,
	0x7b, 0x7b, 0x89, 0x90, 0xd9, 0xe3, 0x1d, 0xda, 0x32, 0xf8, 0xa7, 0x39, 0xbc, 0xfb, 0xb7, 0x22,
	0xb4, 0x5e, 0x1c, 0x68, 0xae, 0x86, 0x46, 0x81, 0xb1, 0xf8, 0x21, 0x54, 0x70, 0x12, 0xae, 0x5c,
	0x24, 0xa6, 0xf6, 0xb3, 0x67, 0xac, 0x94, 0x1d, 0x53, 0x07, 0x24, 0xeb, 0x50, 0x1e, 0x48, 0x91,
	0x69, 0xaf, 0x68, 0x66, 0x5f, 0x3a, 0xcb, 0x78, 0x25, 0x45, 0x46, 0x2d, 0x84, 0xfc, 0x18, 0x6a,
	0x26, 0xd4, 0x19, 0xcb, 0xb8, 0xf3, 0xb9, 0x77, 0x16, 0xff, 0x8c, 0xa5, 0xfb, 0x68, 0xa7, 0x78,
	0x2a, 0xcc, 0x17, 0x79, 0x00, 0x65, 0x3e, 0xe4, 0x32, 0x73, 0x4e, 0xbe, 0x7a, 0x96, 0xf2, 0x39,
	0x1a, 0xa9, 0xc5, 0x90, 0x47, 0xb0, 0xc0, 0x0f, 0x0f, 0x79, 0x90, 0x69, 0xaf, 0x6c, 0x56, 0x74,
	0x6d, 0x0a, 0x6e, 0xcc, 0x34, 0x87, 0x91, 0x87, 0x50, 0x56, 0x2c, 0x64, 0xca, 0xf9, 0x6f, 0x6a,
	0xcf, 0x14, 0x8d, 0x54, 0xc8, 0x88, 0x5a, 0x5c, 0xf7, 0x29, 0xd4, 0x46, 0x3a, 0x72, 0x17, 0x4a,
	0x69, 0xa2, 0x9d, 0xbf, 0xae, 0x9e, 0xeb, 0x7b, 0x8a, 0x08, 0x72, 0x0d, 0x2a, 0x8a, 0x85, 0x62,
	0xa0, 0xcd, 0x69, 0x2d, 0x52, 0x27, 0x75, 0xfb, 0x50, 0xdf, 0x4b, 0x8e, 0xb9, 0xda, 0x4f, 0x06,
	0x2a, 0xe0, 0xff, 0xf7, 0x78, 0xe4, 0x16, 0x94, 0x32, 0x16, 0x19, 0xf7, 0xce, 0x6f, 0xd5, 0xdf,
	0xbf, 0x59, 0x5d, 0xc0, 0x10, 0xbc, 0x64, 0x11, 0x45, 0x7d, 0xf7, 0xaf, 0x05, 0xa8, 0x8d, 0xa2,
	0x48, 0x9e, 0x40, 0x33, 0xc5, 0xc9, 0x7d, 0x6d, 0x66, 0xc7, 0x79, 0xd1, 0x07, 0x37, 0xa7, 0xe7,
	0x1d, 0xad, 0x90, 0x36, 0xd2, 0xb1, 0xa0, 0xc9, 0x27, 0x50, 0x09, 0x58, 0x9f, 0x2b, 0xe6, 0x2e,
	0xe1, 0x05, 0x4b, 0x76, 0x20, 0xb2, 0x01, 0xf5, 0x41, 0x1a, 0x29, 0x16, 0x72, 0x5f, 0x84, 0xda,
	0x2b, 0xad, 0x95, 0xee, 0x35, 0xb7, 0x9a, 0xef, 0xdf, 0xac, 0xd6, 0x5e, 0x59, 0x75, 0x6f, 0x87,
	0x82, 0x43, 0xf4, 0x42, 0xdd, 0xfd, 0x77, 0x01, 0x6a, 0xb8, 0xfe, 0x17, 0x2a, 0xe4, 0x8a, 0x7c,
	0x0c, 0xc0, 0x0e, 0x44, 0x2c, 0xb2, 0x13, 0x5f, 0x84, 0xc6, 0x47, 0x8e, 0xbc, 0x69, 0xb5, 0xbd,
	0x1d, 0x5a, 0x73, 0x80, 0x5e, 0x48, 0x9e, 0xc2, 0xb5, 0x8c, 0xa9, 0x88, 0x67, 0xfe, 0x71, 0xa2,
	0xe2, 0xd0, 0xd7, 0x29, 0x0b, 0xb8, 0x8f, 0xde, 0x9d, 0xb5, 0xd4, 0xdd, 0x39, 0xba, 0x68, 0x69,
	0xbf, 0x45, 0xd6, 0x3e, 0x92, 0xf6, 0x12, 0x3c, 0xbc, 0x6d, 0x37, 0x1a, 0x1e, 0x66, 0xff, 0x7c,
	0x1f, 0xef, 0xce, 0xd1, 0xa6, 0x45, 0x39, 0x05, 0x59, 0x86, 0x6a, 0xaa, 0x92, 0x48, 0x71, 0xad,
	0xcd, 0xf9, 0x2d, 0xd2, 0x91, 0xbc, 0x55, 0x85, 0x8a, 0x05, 0x77, 0x7f, 0x57, 0x84, 0xe6, 0x1e,
	0xd3, 0x9a, 0xcb, 0x88, 0x2b, 0xa4, 0xe6, 0x61, 0x2c, 0x9c, 0x1f, 0x46, 0x8c, 0xfe, 0x11, 0x67,
	0x71, 0x76, 0x94, 0x47, 0xdf, 0x4a, 0xe4, 0x16, 0x80, 0xfd, 0xf2, 0xfb, 0xec, 0x6b, 0xb3, 0xc0,
	0x22, 0xad, 0x59, 0xcd, 0x33, 0xf6, 0x35, 0xd2, 0xf4, 0x91, 0xe0, 0x71, 0xe8, 0xd6, 0xe2, 0x24,
	0xa4, 0xd9, 0x2f, 0x43, 0x5b, 0xb0, 0x34, 0xab, 0x71, 0x34, 0x2e, 0xb9, 0x8a, 0x4e, 0x4c, 0x9a,
	0x2a, 0x52, 0x27, 0x21, 0xcd, 0x7e, 0x19, 0x5a, 0xd5, 0xd2, 0xac, 0x06, 0x69, 0x0f, 0xa0, 0x66,
	0x7d, 0x75, 0x92, 0x72, 0xaf, 0x62, 0xa2, 0xd5, 0x7a, 0xff, 0x66, 0x15, 0xcc, 0x4e, 0x4e, 0x52,
	0x8c, 0x75, 0x75, 0xe0, 0xbe, 0xbb, 0x4f, 0xa1, 0x4e, 0x59, 0x1c, 0x9f, 0xbc, 0x34, 0x1e, 0xc1,
	0x4b, 0x9f, 0x62, 0x38, 0x66, 0xdf, 0x04, 0x8b, 0x21, 0x1d, 0xeb, 0x2c, 0x74, 0xc5, 0xbc, 0x3d,
	0xe6, 0x7f, 0x69, 0xc1, 0xbc, 0xf1, 0xe3, 0x2f, 0xa0, 0x11, 0x0a, 0x8d, 0xc9, 0xca, 0x2e, 0x03,
	0x87, 0x6b, 0x4d, 0x1f, 0xf0, 0x1d, 0x8b, 0xc1, 0x95, 0xd0, 0x7a, 0x38, 0x16, 0xc8, 0x8f, 0xa0,
	0xca, 0xe2, 0x58, 0x30, 0x19, 0x70, 0x33, 0x7e, 0x6b, 0x3a, 0x65, 0x6d, 0x3a, 0x3b, 0x1d, 0x21,
	0x2f, 0xb9, 0x84, 0xa7, 0x1d, 0x33, 0x3f, 0xdb, 0x31, 0xa4, 0x0b, 0xe5, 0xe4, 0x58, 0x72, 0x65,
	0x7c, 0x5f, 0xde, 0x6a, 0xbc, 0x7f, 0xb3, 0x5a, 0xb5, 0x37, 0xb8, 0xb7, 0x43, 0xad, 0x29, 0xcf,
	0x1a, 0x95, 0xef, 0x92, 0x35, 0x0e, 0x59, 0x20, 0x64, 0xe4, 0x82, 0xec, 0xa4, 0x89, 0x6c, 0x52,
	0x3d, 0x95, 0x4d, 0xee, 0x40, 0xeb, 0x60, 0x20, 0xe2, 0xd0, 0x1f, 0x1d, 0xe2, 0x9a, 0xb1, 0x37,
	0x8d, 0x76, 0xcf, 0x29, 0xc9, 0x23, 0x28, 0x07, 0x71, 0xc2, 0x5e, 0x7b, 0x60, 0x5c, 0x34, 0x55,
	0xc6, 0xb6, 0xd1, 0x68, 0xf3, 0xba, 0x05, 0x92, 0x3b, 0x50, 0x3d, 0x18, 0x1c, 0x1e, 0x9a, 0x2c,
	0x70, 0xd3, 0x64, 0x01, 0x78, 0xff, 0x66, 0xb5, 0xb2, 0x35, 0x38, 0x3c, 0xec, 0xed, 0xd0, 0x05,
	0xb4, 0xf5, 0x42, 0x4d, 0x7e, 0x00, 0x8d, 0x90, 0x67, 0x3c, 0xc8, 0x7c, 0xc5, 0x64, 0xc4, 0xbd,
	0x55, 0x33, 0x7b, 0xdd, 0xea, 0x28, 0xaa, 0xc8, 0x2a, 0xd4, 0x4d, 0x5e, 0x76, 0x88, 0x35, 0x83,
	0x00, 0xa3, 0x1a, 0x01, 0x84, 0xf6, 0x35, 0x8f, 0x79, 0x90, 0xf1, 0xd0, 0xab, 0xaf, 0x15, 0xee,
	0x55, 0x29, 0x08, 0xbd, 0xef, 0x34, 0x64, 0x0d, 0x1a, 0x42, 0xfb, 0x89, 0xf4, 0x75, 0xa0, 0x38,
	0x97, 0x5e, 0x23, 0x47, 0xbc, 0x90, 0xfb, 0x46, 0x43, 0xae, 0xc3, 0x82, 0xd0, 0xfe, 0x41, 0x2c,
	0x52, 0xaf, 0x69, 0x8c, 0x15, 0xa1, 0xb7, 0x62, 0x91, 0xe2, 0x0d, 0x10, 0xda, 0x37, 0x19, 0x91,
	0x87, 0xde, 0x6d, 0x63, 0xab, 0x09, 0xbd, 0x67, 0x15, 0xe4, 0x26, 0xd4, 0x84, 0xf6, 0x59, 0x90,
	0x89, 0x21, 0xf7, 0xee, 0x1a, 0x6b, 0x55, 0xe8, 0x4d, 0x23, 0x93, 0x47, 0xb0, 0xc4, 0xb2, 0x8c,
	0x05, 0xaf, 0xfd, 0x3c, 0x25, 0xc6, 0x7c, 0xc8, 0x63, 0xef, 0x1e, 0xc6, 0x99, 0x12, 0x6b, 0x73,
	0x69, 0xf1, 0x29, 0x5a, 0xc8, 0x06, 0x2c, 0x32, 0xd5, 0x4f, 0xd4, 0x19, 0xc2, 0x7d, 0x43, 0xb8,
	0x62, 0x4c, 0xa7, 0xf0, 0x8f, 0x60, 0xc9, 0x5d, 0xeb, 0xd3, 0x84, 0x75, 0x3b, 0x83, 0xb5, 0x9d,
	0x62, 0x8c, 0xf3, 0x4a, 0x6b, 0x46, 0x5e, 0x69, 0x5f, 0x9c, 0x57, 0x3a, 0x33, 0xf2, 0xca, 0x87,
	0x17, 0xe7, 0x95, 0x2b, 0x33, 0xf2, 0xca, 0x9d, 0xb3, 0x79, 0xe5, 0x3e, 0x74, 0xfa, 0x42, 0x72,
	0xc5, 0x62, 0x3f, 0x48, 0x64, 0xc6, 0x65, 0xa6, 0x3d, 0x62, 0xb6, 0xd4, 0x76, 0xfa, 0x6d, 0xa7,
	0x46, 0xe8, 0x90, 0xeb, 0x94, 0x4b, 0x3e, 0x86, 0x2e, 0x5a, 0xa8, 0xd3, 0x8f, 0xa0, 0x36, 0x56,
	0x87, 0xf1, 0x09, 0xde, 0x8e, 0xa5, 0x3c, 0x56, 0x5f, 0x18, 0xd9, 0x9d, 0xa1, 0x83, 0x81, 0x52,
	0xc9, 0x31, 0x0f, 0xbd, 0xab, 0xf9, 0x09, 0xd9, 0x72, 0x1a, 0x9c, 0x48, 0x68, 0xff, 0x88, 0xc5,
	0xf1, 0x20, 0x10, 0xd2, 0x74, 0x54, 0xde, 0x47, 0x06, 0xd5, 0x16, 0x7a, 0x77, 0x52, 0x8d, 0x5d,
	0x56, 0x82, 0xe5, 0x4c, 0x7b, 0xd7, 0xce, 0xef, 0x38, 0x46, 0x05, 0x8f, 0x3a, 0x20, 0xb9, 0x0f,
	0xc0, 0xc2, 0x10, 0x8f, 0x28, 0xa6, 0x95, 0xeb, 0xd3, 0x69, 0xa5, 0xca, 0xc2, 0xf0, 0x85, 0xc4,
	0x82, 0xf3, 0x73, 0x80, 0x34, 0xaf, 0x24, 0xda, 0xf3, 0xcc, 0x0c, 0xb7, 0xa6, 0x32, 0xc2, 0x64,
	0xad, 0xa1, 0x13, 0x04, 0xb2, 0x0e, 0x57, 0x02, 0xa6, 0xa2, 0xc4, 0x55, 0xcb, 0x8c, 0xbd, 0xe6,
	0xd2, 0xbb, 0x61, 0x3d, 0x66, 0x0c, 0xa6, 0x20, 0xbe, 0x44, 0x35, 0xf9, 0x08, 0xda, 0x93, 0x58,
	0x8c, 0xd5, 0xb2, 0x41, 0x36, 0xc7, 0x48, 0x8c, 0xd7, 0x43, 0x58, 0x64, 0x5a, 0x8b, 0x48, 0xf2,
	0xd0, 0x3f, 0x62, 0x6a, 0xc8, 0x75, 0x86, 0x6b, 0xfb, 0xc0, 0x9d, 0x73, 0x67, 0xda, 0x1d, 0x59,
	0x8c, 0x33, 0x43, 0xce, 0xe2, 0x49, 0xf4, 0x2d, 0xbb, 0x06, 0xa3, 0x9f, 0x80, 0xde, 0x85, 0xf6,
	0x31, 0x67, 0x69, 0x22, 0xfd, 0x20, 0x49, 0xe2, 0x30, 0x39, 0x96, 0xde, 0x8a, 0x39, 0x2f, 0x2d,
	0xab, 0xde, 0x76, 0x5a, 0xf2, 0x19, 0x10, 0x2e, 0x23, 0x16, 0xf1, 0xd0, 0x77, 0x75, 0x1c, 0x5d,
	0xd9, 0x9d, 0x76, 0x65, 0xc7, 0xc1, 0x6c, 0x21, 0x42, 0x97, 0x3e, 0x82, 0x25, 0x93, 0xab, 0xc2,
	0x81, 0x32, 0x11, 0xf4, 0x15, 0xef, 0x33, 0x21, 0xbd, 0x07, 0x76, 0x03, 0x68, 0xdb, 0x71, 0x26,
	0x6a, 0x2c, 0xe8, 0xc5, 0xd3, 0x0c, 0xf4, 0xcd, 0xc7, 0x76, 0x07, 0x93, 0x70, 0xf4, 0xce, 0x13,
	0x68, 0x2a, 0x2c, 0x7c, 0x6e, 0x59, 0xda, 0xfb, 0xe4, 0xfc, 0x1e, 0x6c, 0xa2, 0x3a, 0xd2, 0x86,
	0x1a, 0x0b, 0x9a, 0xfc, 0x04, 0x16, 0x30, 0xc5, 0xe0, 0x1b, 0x20, 0x34, 0xdc, 0xb5, 0xa9, 0x12,
	0x35, 0x64, 0x22, 0x36, 0x6f, 0x07, 0xdb, 0x1d, 0xd1, 0x9c, 0xd0, 0x1d, 0x42, 0x35, 0x6f, 0xb9,
	0xc9, 0x67, 0x00, 0x43, 0xa1, 0x85, 0x85, 0x5c, 0xf4, 0x04, 0x18, 0x3f, 0x69, 0x26, 0xc0, 0xd8,
	0x44, 0x63, 0xa6, 0x4c, 0x2f, 0x7f, 0x8a, 0x59, 0x5c, 0xf7, 0x53, 0x28, 0x9b, 0xbe, 0x9d, 0xac,
	0x03, 0x84, 0x9c, 0x85, 0xbe, 0x7d, 0x45, 0x60, 0xff, 0x79, 0x26, 0x1e, 0x35, 0x34, 0xa3, 0xa0,
	0xbb, 0x7f, 0x2f, 0x40, 0xc5, 0xb6, 0xef, 0xe4, 0x3e, 0xd4, 0x6c, 0x03, 0x3f, 0xee, 0x04, 0x4d,
	0x65, 0xb4, 0x66, 0x2c, 0xa0, 0xd6, 0xdc, 0xc3, 0xab, 0x59, 0xb2, 0x4d, 0xdf, 0xcc, 0xe7, 0x91,
	0x29, 0x8f, 0x93, 0xd5, 0xbe, 0xf4, 0x9d, 0xab, 0xfd, 0x52, 0x5e, 0xa1, 0xe7, 0x4d, 0x84, 0x5d,
	0x4d, 0x1e, 0x97, 0xd4, 0xf2, 0xa9, 0x86, 0xff, 0x3f, 0x05, 0xa8, 0x6d, 0x06, 0xf9, 0x93, 0xab,
	0x07, 0x0d, 0xd3, 0x0a, 0xe0, 0x03, 0x99, 0xc9, 0xd0, 0x79, 0xfd, 0xc3, 0xa9, 0x59, 0x73, 0x02,
	0x3a, 0x62, 0xdb, 0x62, 0x77, 0xe7, 0x68, 0x7d, 0x30, 0x16, 0xc9, 0x17, 0x50, 0xb7, 0x5d, 0xb6,
	0xdf, 0x4f, 0x86, 0xdc, 0x45, 0xe2, 0xf6, 0x85, 0x23, 0x6d, 0x1b, 0xec, 0xb3, 0x64, 0xc8, 0x77,
	0xe7, 0x28, 0x04, 0x23, 0x89, 0x50, 0x68, 0x67, 0x49, 0x14, 0xe1, 0xcb, 0x74, 0x90, 0x25, 0x01,
	0xd3, 0xf9, 0x03, 0xf9, 0xee, 0x85, 0x63, 0xbd, 0x34, 0xf8, 0x4d, 0x07, 0xdf, 0x9d, 0xa3, 0xad,
	0xec, 0x94, 0x06, 0x5b, 0x5d, 0x7b, 0xe2, 0xba, 0x7f, 0x2e, 0xc2, 0xd2, 0x79, 0xbb, 0x39, 0xa7,
	0xb9, 0x2f, 0xcf, 0x68, 0xee, 0x9f, 0x5f, 0xd2, 0xdc, 0x5f, 0x14, 0xe7, 0xef, 0xb9, 0xbd, 0xbf,
	0x97, 0x77, 0x72, 0x2c, 0xc2, 0xfe, 0x7e, 0xea, 0xf0, 0xda, 0x36, 0x8e, 0x45, 0x9a, 0xdc, 0x86,
	0xe6, 0x57, 0x03, 0x3e, 0xe0, 0xa3, 0x48, 0x97, 0x4d, 0x75, 0x68, 0x18, 0xa5, 0xf3, 0xc1, 0xc4,
	0x8b, 0xe0, 0x4b, 0x58, 0x3c, 0x27, 0x52, 0x64, 0x1b, 0x48, 0xc0, 0x65, 0xc6, 0xd5, 0xe4, 0xb6,
	0x67, 0xf7, 0xc8, 0x1d, 0x4b, 0x18, 0x6f, 0xb7, 0xfb, 0x15, 0x5c, 0xbf, 0x20, 0x72, 0xff, 0x63,
	0x10, 0x4e, 0xed, 0xbe, 0x38, 0x63, 0xf7, 0xeb, 0x01, 0xd4, 0x27, 0x5a, 0x6c, 0xf2, 0x01, 0xb4,
	0x27, 0x44, 0x5f, 0x8a, 0xb8, 0x33, 0xb7, 0xbc, 0xf0, 0x87, 0x3f, 0xad, 0x95, 0xa4, 0x88, 0x49,
	0x1d, 0x16, 0x7e, 0x83, 0xa9, 0x25, 0xe6, 0x9d, 0x02, 0x69, 0x40, 0x75, 0x5f, 0xb2, 0x54, 0x1f,
	0x25, 0x59, 0xa7, 0x48, 0x00, 0x2a, 0xbb, 0x22, 0x0c, 0xb9, 0xec, 0x94, 0x48, 0x1b, 0xea, 0x7b,
	0x31, 0x0b, 0xf8, 0x51, 0x12, 0x87, 0x5c, 0x75, 0xe6, 0xd7, 0x7f, 0x0d, 0xd5, 0xfc, 0x76, 0x92,
	0x1b, 0xd0, 0xc8, 0xbf, 0xcf, 0x0e, 0x5f, 0x85, 0xf9, 0x7d, 0x1e, 0x1f, 0x76, 0x0a, 0xf8, 0xb5,
	0x19, 0xc7, 0x27, 0x9d, 0x22, 0x4e, 0xf9, 0x9c, 0x0f, 0x32, 0xc5, 0xe2, 0x4e, 0x89, 0xd4, 0xa0,
	0xfc, 0xb9, 0xe4, 0xfd, 0x93, 0xce, 0xfc, 0x3a, 0x07, 0x18, 0xf7, 0xae, 0x84, 0x40, 0xcb, 0x48,
	0x3c, 0x7c, 0x25, 0x5f, 0xcb, 0xe4, 0x58, 0x76, 0xe6, 0x90, 0xe9, 0x74, 0x9d, 0x02, 0x59, 0x84,
	0xb6, 0x13, 0x76, 0x4c, 0x87, 0xca, 0xc3, 0x4e, 0x91, 0xb4, 0x00, 0x9e, 0x27, 0x59, 0x0e, 0x2a,
	0x91, 0x2b, 0xd0, 0x74, 0x02, 0xae, 0x90, 0x87, 0x9d, 0xf9, 0xad, 0xb5, 0x7f, 0xbc, 0x5d, 0x29,
	0x7c, 0xfb, 0x76, 0xa5, 0xf0, 0xaf, 0xb7, 0x2b, 0x85, 0x3f, 0xbe, 0x5b, 0x99, 0xfb, 0xf6, 0xdd,
	0xca, 0xdc, 0x3f, 0xdf, 0xad, 0xcc, 0x7d, 0x59, 0xd9, 0x78, 0xf8, 0x53, 0x96, 0x8a, 0x83, 0x8a,
	0xf9, 0x75, 0xf6, 0xe9, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x8f, 0xe6, 0xb0, 0xb8, 0x71, 0x13,
	0x00, 0x00,
}

func (m *StartRaw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartRaw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartRaw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StartLocations) > 0 {
		for iNdEx := len(m.StartLocations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StartLocations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.PlayableArea != nil {
		{
			size, err := m.PlayableArea.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.PlacementGrid != nil {
		{
			size, err := m.PlacementGrid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TerrainHeight != nil {
		{
			size, err := m.TerrainHeight.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PathingGrid != nil {
		{
			size, err := m.PathingGrid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MapSize != nil {
		{
			size, err := m.MapSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObservationRaw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObservationRaw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObservationRaw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Radar) > 0 {
		for iNdEx := len(m.Radar) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Radar[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Effects) > 0 {
		for iNdEx := len(m.Effects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Effects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Event != nil {
		{
			size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MapState != nil {
		{
			size, err := m.MapState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Units) > 0 {
		for iNdEx := len(m.Units) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Units[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Player != nil {
		{
			size, err := m.Player.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RadarRing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RadarRing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RadarRing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Radius != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Radius))))
		i--
		dAtA[i] = 0x15
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PowerSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PowerSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PowerSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x18
	}
	if m.Radius != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Radius))))
		i--
		dAtA[i] = 0x15
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlayerRaw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerRaw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerRaw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpgradeIds) > 0 {
		dAtA12 := make([]byte, len(m.UpgradeIds)*10)
		var j11 int
		for _, num := range m.UpgradeIds {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintRaw(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x1a
	}
	if m.Camera != nil {
		{
			size, err := m.Camera.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.PowerSources) > 0 {
		for iNdEx := len(m.PowerSources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PowerSources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UnitOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnitOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnitOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Progress != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Progress))))
		i--
		dAtA[i] = 0x25
	}
	if m.Target != nil {
		{
			size := m.Target.Size()
			i -= size
			if _, err := m.Target.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AbilityId != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.AbilityId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnitOrder_TargetWorldSpacePos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnitOrder_TargetWorldSpacePos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TargetWorldSpacePos != nil {
		{
			size, err := m.TargetWorldSpacePos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *UnitOrder_TargetUnitTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnitOrder_TargetUnitTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintRaw(dAtA, i, uint64(m.TargetUnitTag))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *PassengerUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PassengerUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PassengerUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnergyMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EnergyMax))))
		i--
		dAtA[i] = 0x45
	}
	if m.ShieldMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ShieldMax))))
		i--
		dAtA[i] = 0x3d
	}
	if m.UnitType != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.UnitType))
		i--
		dAtA[i] = 0x30
	}
	if m.Energy != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Shield != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Shield))))
		i--
		dAtA[i] = 0x25
	}
	if m.HealthMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HealthMax))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Health != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Health))))
		i--
		dAtA[i] = 0x15
	}
	if m.Tag != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RallyTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RallyTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RallyTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x10
	}
	if m.Point != nil {
		{
			size, err := m.Point.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Unit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Unit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Unit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.RallyTargets) > 0 {
		for iNdEx := len(m.RallyTargets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RallyTargets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	if m.BuffDurationMax != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.BuffDurationMax))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.BuffDurationRemain != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.BuffDurationRemain))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.ShieldUpgradeLevel != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.ShieldUpgradeLevel))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.ArmorUpgradeLevel != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.ArmorUpgradeLevel))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.AttackUpgradeLevel != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.AttackUpgradeLevel))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.IsHallucination {
		i--
		if m.IsHallucination {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.EnergyMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EnergyMax))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xad
	}
	if m.ShieldMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ShieldMax))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa5
	}
	if m.IsPowered {
		i--
		if m.IsPowered {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.EngagedTargetTag != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.EngagedTargetTag))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.RadarRange != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RadarRange))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x85
	}
	if m.DetectRange != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DetectRange))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfd
	}
	if m.WeaponCooldown != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WeaponCooldown))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf5
	}
	if m.IdealHarvesters != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.IdealHarvesters))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.AssignedHarvesters != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.AssignedHarvesters))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if len(m.BuffIds) > 0 {
		dAtA17 := make([]byte, len(m.BuffIds)*10)
		var j16 int
		for _, num := range m.BuffIds {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintRaw(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.CargoSpaceMax != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.CargoSpaceMax))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.CargoSpaceTaken != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.CargoSpaceTaken))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.Passengers) > 0 {
		for iNdEx := len(m.Passengers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Passengers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if m.AddOnTag != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.AddOnTag))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.Orders) > 0 {
		for iNdEx := len(m.Orders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Orders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.IsBurrowed {
		i--
		if m.IsBurrowed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.IsFlying {
		i--
		if m.IsFlying {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.VespeneContents != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.VespeneContents))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.MineralContents != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.MineralContents))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Energy != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8d
	}
	if m.Shield != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Shield))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x85
	}
	if m.HealthMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HealthMax))))
		i--
		dAtA[i] = 0x7d
	}
	if m.Health != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Health))))
		i--
		dAtA[i] = 0x75
	}
	if m.IsBlip {
		i--
		if m.IsBlip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.IsOnScreen {
		i--
		if m.IsOnScreen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.IsSelected {
		i--
		if m.IsSelected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Cloak != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.Cloak))
		i--
		dAtA[i] = 0x50
	}
	if m.BuildProgress != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BuildProgress))))
		i--
		dAtA[i] = 0x4d
	}
	if m.Radius != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Radius))))
		i--
		dAtA[i] = 0x45
	}
	if m.Facing != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Facing))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Owner != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.Owner))
		i--
		dAtA[i] = 0x28
	}
	if m.UnitType != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.UnitType))
		i--
		dAtA[i] = 0x20
	}
	if m.Tag != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x18
	}
	if m.Alliance != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.Alliance))
		i--
		dAtA[i] = 0x10
	}
	if m.DisplayType != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.DisplayType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MapState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MapState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Creep != nil {
		{
			size, err := m.Creep.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Visibility != nil {
		{
			size, err := m.Visibility.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeadUnits) > 0 {
		dAtA22 := make([]byte, len(m.DeadUnits)*10)
		var j21 int
		for _, num := range m.DeadUnits {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintRaw(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Effect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Effect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Effect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Radius != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Radius))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Owner != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.Owner))
		i--
		dAtA[i] = 0x20
	}
	if m.Alliance != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.Alliance))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Pos) > 0 {
		for iNdEx := len(m.Pos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaw(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.EffectId != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.EffectId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActionRaw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionRaw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionRaw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size := m.Action.Size()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionRaw_UnitCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionRaw_UnitCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UnitCommand != nil {
		{
			size, err := m.UnitCommand.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ActionRaw_CameraMove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionRaw_CameraMove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CameraMove != nil {
		{
			size, err := m.CameraMove.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ActionRaw_ToggleAutocast) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionRaw_ToggleAutocast) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ToggleAutocast != nil {
		{
			size, err := m.ToggleAutocast.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ActionRawUnitCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionRawUnitCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionRawUnitCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QueueCommand {
		i--
		if m.QueueCommand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.UnitTags) > 0 {
		dAtA27 := make([]byte, len(m.UnitTags)*10)
		var j26 int
		for _, num := range m.UnitTags {
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintRaw(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0x22
	}
	if m.Target != nil {
		{
			size := m.Target.Size()
			i -= size
			if _, err := m.Target.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AbilityId != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.AbilityId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActionRawUnitCommand_TargetWorldSpacePos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionRawUnitCommand_TargetWorldSpacePos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TargetWorldSpacePos != nil {
		{
			size, err := m.TargetWorldSpacePos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ActionRawUnitCommand_TargetUnitTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionRawUnitCommand_TargetUnitTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintRaw(dAtA, i, uint64(m.TargetUnitTag))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *ActionRawCameraMove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionRawCameraMove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionRawCameraMove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CenterWorldSpace != nil {
		{
			size, err := m.CenterWorldSpace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaw(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionRawToggleAutocast) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionRawToggleAutocast) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionRawToggleAutocast) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UnitTags) > 0 {
		dAtA31 := make([]byte, len(m.UnitTags)*10)
		var j30 int
		for _, num := range m.UnitTags {
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		i -= j30
		copy(dAtA[i:], dAtA31[:j30])
		i = encodeVarintRaw(dAtA, i, uint64(j30))
		i--
		dAtA[i] = 0x12
	}
	if m.AbilityId != 0 {
		i = encodeVarintRaw(dAtA, i, uint64(m.AbilityId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRaw(dAtA []byte, offset int, v uint64) int {
	offset -= sovRaw(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StartRaw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MapSize != nil {
		l = m.MapSize.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.PathingGrid != nil {
		l = m.PathingGrid.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.TerrainHeight != nil {
		l = m.TerrainHeight.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.PlacementGrid != nil {
		l = m.PlacementGrid.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.PlayableArea != nil {
		l = m.PlayableArea.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if len(m.StartLocations) > 0 {
		for _, e := range m.StartLocations {
			l = e.Size()
			n += 1 + l + sovRaw(uint64(l))
		}
	}
	return n
}

func (m *ObservationRaw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if len(m.Units) > 0 {
		for _, e := range m.Units {
			l = e.Size()
			n += 1 + l + sovRaw(uint64(l))
		}
	}
	if m.MapState != nil {
		l = m.MapState.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if len(m.Effects) > 0 {
		for _, e := range m.Effects {
			l = e.Size()
			n += 1 + l + sovRaw(uint64(l))
		}
	}
	if len(m.Radar) > 0 {
		for _, e := range m.Radar {
			l = e.Size()
			n += 1 + l + sovRaw(uint64(l))
		}
	}
	return n
}

func (m *RadarRing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.Radius != 0 {
		n += 5
	}
	return n
}

func (m *PowerSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.Radius != 0 {
		n += 5
	}
	if m.Tag != 0 {
		n += 1 + sovRaw(uint64(m.Tag))
	}
	return n
}

func (m *PlayerRaw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PowerSources) > 0 {
		for _, e := range m.PowerSources {
			l = e.Size()
			n += 1 + l + sovRaw(uint64(l))
		}
	}
	if m.Camera != nil {
		l = m.Camera.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if len(m.UpgradeIds) > 0 {
		l = 0
		for _, e := range m.UpgradeIds {
			l += sovRaw(uint64(e))
		}
		n += 1 + sovRaw(uint64(l)) + l
	}
	return n
}

func (m *UnitOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AbilityId != 0 {
		n += 1 + sovRaw(uint64(m.AbilityId))
	}
	if m.Target != nil {
		n += m.Target.Size()
	}
	if m.Progress != 0 {
		n += 5
	}
	return n
}

func (m *UnitOrder_TargetWorldSpacePos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetWorldSpacePos != nil {
		l = m.TargetWorldSpacePos.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	return n
}
func (m *UnitOrder_TargetUnitTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaw(uint64(m.TargetUnitTag))
	return n
}
func (m *PassengerUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovRaw(uint64(m.Tag))
	}
	if m.Health != 0 {
		n += 5
	}
	if m.HealthMax != 0 {
		n += 5
	}
	if m.Shield != 0 {
		n += 5
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.UnitType != 0 {
		n += 1 + sovRaw(uint64(m.UnitType))
	}
	if m.ShieldMax != 0 {
		n += 5
	}
	if m.EnergyMax != 0 {
		n += 5
	}
	return n
}

func (m *RallyTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.Tag != 0 {
		n += 1 + sovRaw(uint64(m.Tag))
	}
	return n
}

func (m *Unit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisplayType != 0 {
		n += 1 + sovRaw(uint64(m.DisplayType))
	}
	if m.Alliance != 0 {
		n += 1 + sovRaw(uint64(m.Alliance))
	}
	if m.Tag != 0 {
		n += 1 + sovRaw(uint64(m.Tag))
	}
	if m.UnitType != 0 {
		n += 1 + sovRaw(uint64(m.UnitType))
	}
	if m.Owner != 0 {
		n += 1 + sovRaw(uint64(m.Owner))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.Facing != 0 {
		n += 5
	}
	if m.Radius != 0 {
		n += 5
	}
	if m.BuildProgress != 0 {
		n += 5
	}
	if m.Cloak != 0 {
		n += 1 + sovRaw(uint64(m.Cloak))
	}
	if m.IsSelected {
		n += 2
	}
	if m.IsOnScreen {
		n += 2
	}
	if m.IsBlip {
		n += 2
	}
	if m.Health != 0 {
		n += 5
	}
	if m.HealthMax != 0 {
		n += 5
	}
	if m.Shield != 0 {
		n += 6
	}
	if m.Energy != 0 {
		n += 6
	}
	if m.MineralContents != 0 {
		n += 2 + sovRaw(uint64(m.MineralContents))
	}
	if m.VespeneContents != 0 {
		n += 2 + sovRaw(uint64(m.VespeneContents))
	}
	if m.IsFlying {
		n += 3
	}
	if m.IsBurrowed {
		n += 3
	}
	if len(m.Orders) > 0 {
		for _, e := range m.Orders {
			l = e.Size()
			n += 2 + l + sovRaw(uint64(l))
		}
	}
	if m.AddOnTag != 0 {
		n += 2 + sovRaw(uint64(m.AddOnTag))
	}
	if len(m.Passengers) > 0 {
		for _, e := range m.Passengers {
			l = e.Size()
			n += 2 + l + sovRaw(uint64(l))
		}
	}
	if m.CargoSpaceTaken != 0 {
		n += 2 + sovRaw(uint64(m.CargoSpaceTaken))
	}
	if m.CargoSpaceMax != 0 {
		n += 2 + sovRaw(uint64(m.CargoSpaceMax))
	}
	if len(m.BuffIds) > 0 {
		l = 0
		for _, e := range m.BuffIds {
			l += sovRaw(uint64(e))
		}
		n += 2 + sovRaw(uint64(l)) + l
	}
	if m.AssignedHarvesters != 0 {
		n += 2 + sovRaw(uint64(m.AssignedHarvesters))
	}
	if m.IdealHarvesters != 0 {
		n += 2 + sovRaw(uint64(m.IdealHarvesters))
	}
	if m.WeaponCooldown != 0 {
		n += 6
	}
	if m.DetectRange != 0 {
		n += 6
	}
	if m.RadarRange != 0 {
		n += 6
	}
	if m.EngagedTargetTag != 0 {
		n += 2 + sovRaw(uint64(m.EngagedTargetTag))
	}
	if m.IsPowered {
		n += 3
	}
	if m.ShieldMax != 0 {
		n += 6
	}
	if m.EnergyMax != 0 {
		n += 6
	}
	if m.IsHallucination {
		n += 3
	}
	if m.IsActive {
		n += 3
	}
	if m.AttackUpgradeLevel != 0 {
		n += 2 + sovRaw(uint64(m.AttackUpgradeLevel))
	}
	if m.ArmorUpgradeLevel != 0 {
		n += 2 + sovRaw(uint64(m.ArmorUpgradeLevel))
	}
	if m.ShieldUpgradeLevel != 0 {
		n += 2 + sovRaw(uint64(m.ShieldUpgradeLevel))
	}
	if m.BuffDurationRemain != 0 {
		n += 2 + sovRaw(uint64(m.BuffDurationRemain))
	}
	if m.BuffDurationMax != 0 {
		n += 2 + sovRaw(uint64(m.BuffDurationMax))
	}
	if len(m.RallyTargets) > 0 {
		for _, e := range m.RallyTargets {
			l = e.Size()
			n += 2 + l + sovRaw(uint64(l))
		}
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 2 + l + sovRaw(uint64(l))
		}
	}
	return n
}

func (m *MapState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Visibility != nil {
		l = m.Visibility.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	if m.Creep != nil {
		l = m.Creep.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DeadUnits) > 0 {
		l = 0
		for _, e := range m.DeadUnits {
			l += sovRaw(uint64(e))
		}
		n += 1 + sovRaw(uint64(l)) + l
	}
	return n
}

func (m *Effect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EffectId != 0 {
		n += 1 + sovRaw(uint64(m.EffectId))
	}
	if len(m.Pos) > 0 {
		for _, e := range m.Pos {
			l = e.Size()
			n += 1 + l + sovRaw(uint64(l))
		}
	}
	if m.Alliance != 0 {
		n += 1 + sovRaw(uint64(m.Alliance))
	}
	if m.Owner != 0 {
		n += 1 + sovRaw(uint64(m.Owner))
	}
	if m.Radius != 0 {
		n += 5
	}
	return n
}

func (m *ActionRaw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *ActionRaw_UnitCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnitCommand != nil {
		l = m.UnitCommand.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	return n
}
func (m *ActionRaw_CameraMove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CameraMove != nil {
		l = m.CameraMove.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	return n
}
func (m *ActionRaw_ToggleAutocast) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToggleAutocast != nil {
		l = m.ToggleAutocast.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	return n
}
func (m *ActionRawUnitCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AbilityId != 0 {
		n += 1 + sovRaw(uint64(m.AbilityId))
	}
	if m.Target != nil {
		n += m.Target.Size()
	}
	if len(m.UnitTags) > 0 {
		l = 0
		for _, e := range m.UnitTags {
			l += sovRaw(uint64(e))
		}
		n += 1 + sovRaw(uint64(l)) + l
	}
	if m.QueueCommand {
		n += 2
	}
	return n
}

func (m *ActionRawUnitCommand_TargetWorldSpacePos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetWorldSpacePos != nil {
		l = m.TargetWorldSpacePos.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	return n
}
func (m *ActionRawUnitCommand_TargetUnitTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaw(uint64(m.TargetUnitTag))
	return n
}
func (m *ActionRawCameraMove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CenterWorldSpace != nil {
		l = m.CenterWorldSpace.Size()
		n += 1 + l + sovRaw(uint64(l))
	}
	return n
}

func (m *ActionRawToggleAutocast) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AbilityId != 0 {
		n += 1 + sovRaw(uint64(m.AbilityId))
	}
	if len(m.UnitTags) > 0 {
		l = 0
		for _, e := range m.UnitTags {
			l += sovRaw(uint64(e))
		}
		n += 1 + sovRaw(uint64(l)) + l
	}
	return n
}

func sovRaw(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRaw(x uint64) (n int) {
	return sovRaw(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StartRaw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartRaw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartRaw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapSize == nil {
				m.MapSize = &Size2DI{}
			}
			if err := m.MapSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathingGrid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PathingGrid == nil {
				m.PathingGrid = &ImageData{}
			}
			if err := m.PathingGrid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerrainHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TerrainHeight == nil {
				m.TerrainHeight = &ImageData{}
			}
			if err := m.TerrainHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementGrid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlacementGrid == nil {
				m.PlacementGrid = &ImageData{}
			}
			if err := m.PlacementGrid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayableArea", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayableArea == nil {
				m.PlayableArea = &RectangleI{}
			}
			if err := m.PlayableArea.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartLocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartLocations = append(m.StartLocations, &Point2D{})
			if err := m.StartLocations[len(m.StartLocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObservationRaw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObservationRaw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObservationRaw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &PlayerRaw{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Units = append(m.Units, &Unit{})
			if err := m.Units[len(m.Units)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapState == nil {
				m.MapState = &MapState{}
			}
			if err := m.MapState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &Event{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Effects = append(m.Effects, &Effect{})
			if err := m.Effects[len(m.Effects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Radar = append(m.Radar, &RadarRing{})
			if err := m.Radar[len(m.Radar)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RadarRing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RadarRing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RadarRing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Point{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Radius = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PowerSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PowerSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PowerSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Point{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Radius = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= UnitTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerRaw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerRaw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerRaw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerSources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PowerSources = append(m.PowerSources, &PowerSource{})
			if err := m.PowerSources[len(m.PowerSources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camera", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Camera == nil {
				m.Camera = &Point{}
			}
			if err := m.Camera.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v UpgradeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= UpgradeID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UpgradeIds = append(m.UpgradeIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRaw
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRaw
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UpgradeIds) == 0 {
					m.UpgradeIds = make([]UpgradeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UpgradeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= UpgradeID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UpgradeIds = append(m.UpgradeIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnitOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnitOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnitOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityId", wireType)
			}
			m.AbilityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbilityId |= AbilityID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetWorldSpacePos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Point{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &UnitOrder_TargetWorldSpacePos{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetUnitTag", wireType)
			}
			var v UnitTag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= UnitTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Target = &UnitOrder_TargetUnitTag{v}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Progress = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PassengerUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PassengerUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PassengerUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= UnitTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Health = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HealthMax = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shield", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Shield = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			m.UnitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitType |= UnitTypeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShieldMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ShieldMax = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EnergyMax = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RallyTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RallyTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RallyTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Unit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Unit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Unit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayType", wireType)
			}
			m.DisplayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisplayType |= DisplayType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alliance", wireType)
			}
			m.Alliance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alliance |= Alliance(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= UnitTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			m.UnitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitType |= UnitTypeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= PlayerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Point{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Facing", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Facing = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Radius = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildProgress", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BuildProgress = float32(math.Float32frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloak", wireType)
			}
			m.Cloak = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cloak |= CloakState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSelected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSelected = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOnScreen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOnScreen = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBlip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBlip = bool(v != 0)
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Health = float32(math.Float32frombits(v))
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HealthMax = float32(math.Float32frombits(v))
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shield", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Shield = float32(math.Float32frombits(v))
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MineralContents", wireType)
			}
			m.MineralContents = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MineralContents |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VespeneContents", wireType)
			}
			m.VespeneContents = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VespeneContents |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFlying", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFlying = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBurrowed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBurrowed = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orders = append(m.Orders, &UnitOrder{})
			if err := m.Orders[len(m.Orders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddOnTag", wireType)
			}
			m.AddOnTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddOnTag |= UnitTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passengers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Passengers = append(m.Passengers, &PassengerUnit{})
			if err := m.Passengers[len(m.Passengers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CargoSpaceTaken", wireType)
			}
			m.CargoSpaceTaken = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CargoSpaceTaken |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CargoSpaceMax", wireType)
			}
			m.CargoSpaceMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CargoSpaceMax |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType == 0 {
				var v BuffID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= BuffID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BuffIds = append(m.BuffIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRaw
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRaw
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BuffIds) == 0 {
					m.BuffIds = make([]BuffID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v BuffID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= BuffID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BuffIds = append(m.BuffIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffIds", wireType)
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedHarvesters", wireType)
			}
			m.AssignedHarvesters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignedHarvesters |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdealHarvesters", wireType)
			}
			m.IdealHarvesters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdealHarvesters |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeaponCooldown", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WeaponCooldown = float32(math.Float32frombits(v))
		case 31:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectRange", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DetectRange = float32(math.Float32frombits(v))
		case 32:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RadarRange", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RadarRange = float32(math.Float32frombits(v))
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EngagedTargetTag", wireType)
			}
			m.EngagedTargetTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EngagedTargetTag |= UnitTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPowered", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPowered = bool(v != 0)
		case 36:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShieldMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ShieldMax = float32(math.Float32frombits(v))
		case 37:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EnergyMax = float32(math.Float32frombits(v))
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHallucination", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHallucination = bool(v != 0)
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackUpgradeLevel", wireType)
			}
			m.AttackUpgradeLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackUpgradeLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArmorUpgradeLevel", wireType)
			}
			m.ArmorUpgradeLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArmorUpgradeLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShieldUpgradeLevel", wireType)
			}
			m.ShieldUpgradeLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShieldUpgradeLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffDurationRemain", wireType)
			}
			m.BuffDurationRemain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffDurationRemain |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffDurationMax", wireType)
			}
			m.BuffDurationMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffDurationMax |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RallyTargets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RallyTargets = append(m.RallyTargets, &RallyTarget{})
			if err := m.RallyTargets[len(m.RallyTargets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &AvailableAbility{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Visibility == nil {
				m.Visibility = &ImageData{}
			}
			if err := m.Visibility.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creep == nil {
				m.Creep = &ImageData{}
			}
			if err := m.Creep.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v UnitTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= UnitTag(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DeadUnits = append(m.DeadUnits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRaw
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRaw
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DeadUnits) == 0 {
					m.DeadUnits = make([]UnitTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UnitTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= UnitTag(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DeadUnits = append(m.DeadUnits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadUnits", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Effect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Effect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Effect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectId", wireType)
			}
			m.EffectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectId |= EffectID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = append(m.Pos, &Point2D{})
			if err := m.Pos[len(m.Pos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alliance", wireType)
			}
			m.Alliance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alliance |= Alliance(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Radius = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionRaw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionRaw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionRaw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitCommand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActionRawUnitCommand{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionRaw_UnitCommand{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CameraMove", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActionRawCameraMove{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionRaw_CameraMove{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToggleAutocast", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActionRawToggleAutocast{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &ActionRaw_ToggleAutocast{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionRawUnitCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionRawUnitCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionRawUnitCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityId", wireType)
			}
			m.AbilityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbilityId |= AbilityID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetWorldSpacePos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Point2D{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &ActionRawUnitCommand_TargetWorldSpacePos{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetUnitTag", wireType)
			}
			var v UnitTag
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= UnitTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Target = &ActionRawUnitCommand_TargetUnitTag{v}
		case 4:
			if wireType == 0 {
				var v UnitTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= UnitTag(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnitTags = append(m.UnitTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRaw
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRaw
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnitTags) == 0 {
					m.UnitTags = make([]UnitTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UnitTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= UnitTag(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnitTags = append(m.UnitTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTags", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueCommand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueueCommand = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionRawCameraMove) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionRawCameraMove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionRawCameraMove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CenterWorldSpace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaw
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaw
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CenterWorldSpace == nil {
				m.CenterWorldSpace = &Point{}
			}
			if err := m.CenterWorldSpace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionRawToggleAutocast) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionRawToggleAutocast: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionRawToggleAutocast: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbilityId", wireType)
			}
			m.AbilityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AbilityId |= AbilityID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v UnitTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= UnitTag(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnitTags = append(m.UnitTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaw
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRaw
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRaw
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnitTags) == 0 {
					m.UnitTags = make([]UnitTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UnitTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaw
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= UnitTag(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnitTags = append(m.UnitTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTags", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaw(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaw
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaw(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaw
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaw
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRaw
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRaw
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRaw
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRaw        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaw          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRaw = fmt.Errorf("proto: unexpected end of group")
)
