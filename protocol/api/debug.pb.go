// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: debug.proto

package api

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DebugGameState int32

const (
	DebugGameState_nil           DebugGameState = 0
	DebugGameState_show_map      DebugGameState = 1
	DebugGameState_control_enemy DebugGameState = 2
	DebugGameState_food          DebugGameState = 3
	DebugGameState_free          DebugGameState = 4
	DebugGameState_all_resources DebugGameState = 5
	DebugGameState_god           DebugGameState = 6
	DebugGameState_minerals      DebugGameState = 7
	DebugGameState_gas           DebugGameState = 8
	DebugGameState_cooldown      DebugGameState = 9
	DebugGameState_tech_tree     DebugGameState = 10
	DebugGameState_upgrade       DebugGameState = 11
	DebugGameState_fast_build    DebugGameState = 12
)

var DebugGameState_name = map[int32]string{
	0:  "DebugGameState_nil",
	1:  "show_map",
	2:  "control_enemy",
	3:  "food",
	4:  "free",
	5:  "all_resources",
	6:  "god",
	7:  "minerals",
	8:  "gas",
	9:  "cooldown",
	10: "tech_tree",
	11: "upgrade",
	12: "fast_build",
}

var DebugGameState_value = map[string]int32{
	"DebugGameState_nil": 0,
	"show_map":           1,
	"control_enemy":      2,
	"food":               3,
	"free":               4,
	"all_resources":      5,
	"god":                6,
	"minerals":           7,
	"gas":                8,
	"cooldown":           9,
	"tech_tree":          10,
	"upgrade":            11,
	"fast_build":         12,
}

func (x DebugGameState) String() string {
	return proto.EnumName(DebugGameState_name, int32(x))
}

func (DebugGameState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{0}
}

type DebugTestProcess_Test int32

const (
	DebugTestProcess_nil   DebugTestProcess_Test = 0
	DebugTestProcess_hang  DebugTestProcess_Test = 1
	DebugTestProcess_crash DebugTestProcess_Test = 2
	DebugTestProcess_exit  DebugTestProcess_Test = 3
)

var DebugTestProcess_Test_name = map[int32]string{
	0: "Test_nil",
	1: "hang",
	2: "crash",
	3: "exit",
}

var DebugTestProcess_Test_value = map[string]int32{
	"Test_nil": 0,
	"hang":     1,
	"crash":    2,
	"exit":     3,
}

func (x DebugTestProcess_Test) String() string {
	return proto.EnumName(DebugTestProcess_Test_name, int32(x))
}

func (DebugTestProcess_Test) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{10, 0}
}

type DebugEndGame_EndResult int32

const (
	DebugEndGame_nil            DebugEndGame_EndResult = 0
	DebugEndGame_Surrender      DebugEndGame_EndResult = 1
	DebugEndGame_DeclareVictory DebugEndGame_EndResult = 2
)

var DebugEndGame_EndResult_name = map[int32]string{
	0: "EndResult_nil",
	1: "Surrender",
	2: "DeclareVictory",
}

var DebugEndGame_EndResult_value = map[string]int32{
	"EndResult_nil":  0,
	"Surrender":      1,
	"DeclareVictory": 2,
}

func (x DebugEndGame_EndResult) String() string {
	return proto.EnumName(DebugEndGame_EndResult_name, int32(x))
}

func (DebugEndGame_EndResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{12, 0}
}

type DebugSetUnitValue_UnitValue int32

const (
	DebugSetUnitValue_nil     DebugSetUnitValue_UnitValue = 0
	DebugSetUnitValue_Energy  DebugSetUnitValue_UnitValue = 1
	DebugSetUnitValue_Life    DebugSetUnitValue_UnitValue = 2
	DebugSetUnitValue_Shields DebugSetUnitValue_UnitValue = 3
)

var DebugSetUnitValue_UnitValue_name = map[int32]string{
	0: "UnitValue_nil",
	1: "Energy",
	2: "Life",
	3: "Shields",
}

var DebugSetUnitValue_UnitValue_value = map[string]int32{
	"UnitValue_nil": 0,
	"Energy":        1,
	"Life":          2,
	"Shields":       3,
}

func (x DebugSetUnitValue_UnitValue) String() string {
	return proto.EnumName(DebugSetUnitValue_UnitValue_name, int32(x))
}

func (DebugSetUnitValue_UnitValue) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{13, 0}
}

// Issue various useful commands to the game engine.
type DebugCommand struct {
	// Types that are valid to be assigned to Command:
	//	*DebugCommand_Draw
	//	*DebugCommand_GameState
	//	*DebugCommand_CreateUnit
	//	*DebugCommand_KillUnit
	//	*DebugCommand_TestProcess
	//	*DebugCommand_Score
	//	*DebugCommand_EndGame
	//	*DebugCommand_UnitValue
	Command isDebugCommand_Command `protobuf_oneof:"command"`
}

func (m *DebugCommand) Reset()         { *m = DebugCommand{} }
func (m *DebugCommand) String() string { return proto.CompactTextString(m) }
func (*DebugCommand) ProtoMessage()    {}
func (*DebugCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{0}
}
func (m *DebugCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugCommand.Merge(m, src)
}
func (m *DebugCommand) XXX_Size() int {
	return m.Size()
}
func (m *DebugCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugCommand.DiscardUnknown(m)
}

var xxx_messageInfo_DebugCommand proto.InternalMessageInfo

type isDebugCommand_Command interface {
	isDebugCommand_Command()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DebugCommand_Draw struct {
	Draw *DebugDraw `protobuf:"bytes,1,opt,name=draw,proto3,oneof" json:"draw,omitempty"`
}
type DebugCommand_GameState struct {
	GameState DebugGameState `protobuf:"varint,2,opt,name=game_state,json=gameState,proto3,enum=SC2APIProtocol.DebugGameState,oneof" json:"game_state,omitempty"`
}
type DebugCommand_CreateUnit struct {
	CreateUnit *DebugCreateUnit `protobuf:"bytes,3,opt,name=create_unit,json=createUnit,proto3,oneof" json:"create_unit,omitempty"`
}
type DebugCommand_KillUnit struct {
	KillUnit *DebugKillUnit `protobuf:"bytes,4,opt,name=kill_unit,json=killUnit,proto3,oneof" json:"kill_unit,omitempty"`
}
type DebugCommand_TestProcess struct {
	TestProcess *DebugTestProcess `protobuf:"bytes,5,opt,name=test_process,json=testProcess,proto3,oneof" json:"test_process,omitempty"`
}
type DebugCommand_Score struct {
	Score *DebugSetScore `protobuf:"bytes,6,opt,name=score,proto3,oneof" json:"score,omitempty"`
}
type DebugCommand_EndGame struct {
	EndGame *DebugEndGame `protobuf:"bytes,7,opt,name=end_game,json=endGame,proto3,oneof" json:"end_game,omitempty"`
}
type DebugCommand_UnitValue struct {
	UnitValue *DebugSetUnitValue `protobuf:"bytes,8,opt,name=unit_value,json=unitValue,proto3,oneof" json:"unit_value,omitempty"`
}

func (*DebugCommand_Draw) isDebugCommand_Command()        {}
func (*DebugCommand_GameState) isDebugCommand_Command()   {}
func (*DebugCommand_CreateUnit) isDebugCommand_Command()  {}
func (*DebugCommand_KillUnit) isDebugCommand_Command()    {}
func (*DebugCommand_TestProcess) isDebugCommand_Command() {}
func (*DebugCommand_Score) isDebugCommand_Command()       {}
func (*DebugCommand_EndGame) isDebugCommand_Command()     {}
func (*DebugCommand_UnitValue) isDebugCommand_Command()   {}

func (m *DebugCommand) GetCommand() isDebugCommand_Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *DebugCommand) GetDraw() *DebugDraw {
	if x, ok := m.GetCommand().(*DebugCommand_Draw); ok {
		return x.Draw
	}
	return nil
}

func (m *DebugCommand) GetGameState() DebugGameState {
	if x, ok := m.GetCommand().(*DebugCommand_GameState); ok {
		return x.GameState
	}
	return DebugGameState_nil
}

func (m *DebugCommand) GetCreateUnit() *DebugCreateUnit {
	if x, ok := m.GetCommand().(*DebugCommand_CreateUnit); ok {
		return x.CreateUnit
	}
	return nil
}

func (m *DebugCommand) GetKillUnit() *DebugKillUnit {
	if x, ok := m.GetCommand().(*DebugCommand_KillUnit); ok {
		return x.KillUnit
	}
	return nil
}

func (m *DebugCommand) GetTestProcess() *DebugTestProcess {
	if x, ok := m.GetCommand().(*DebugCommand_TestProcess); ok {
		return x.TestProcess
	}
	return nil
}

func (m *DebugCommand) GetScore() *DebugSetScore {
	if x, ok := m.GetCommand().(*DebugCommand_Score); ok {
		return x.Score
	}
	return nil
}

func (m *DebugCommand) GetEndGame() *DebugEndGame {
	if x, ok := m.GetCommand().(*DebugCommand_EndGame); ok {
		return x.EndGame
	}
	return nil
}

func (m *DebugCommand) GetUnitValue() *DebugSetUnitValue {
	if x, ok := m.GetCommand().(*DebugCommand_UnitValue); ok {
		return x.UnitValue
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DebugCommand) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DebugCommand_Draw)(nil),
		(*DebugCommand_GameState)(nil),
		(*DebugCommand_CreateUnit)(nil),
		(*DebugCommand_KillUnit)(nil),
		(*DebugCommand_TestProcess)(nil),
		(*DebugCommand_Score)(nil),
		(*DebugCommand_EndGame)(nil),
		(*DebugCommand_UnitValue)(nil),
	}
}

type DebugDraw struct {
	Text    []*DebugText   `protobuf:"bytes,1,rep,name=text,proto3" json:"text,omitempty"`
	Lines   []*DebugLine   `protobuf:"bytes,2,rep,name=lines,proto3" json:"lines,omitempty"`
	Boxes   []*DebugBox    `protobuf:"bytes,3,rep,name=boxes,proto3" json:"boxes,omitempty"`
	Spheres []*DebugSphere `protobuf:"bytes,4,rep,name=spheres,proto3" json:"spheres,omitempty"`
}

func (m *DebugDraw) Reset()         { *m = DebugDraw{} }
func (m *DebugDraw) String() string { return proto.CompactTextString(m) }
func (*DebugDraw) ProtoMessage()    {}
func (*DebugDraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{1}
}
func (m *DebugDraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugDraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugDraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugDraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugDraw.Merge(m, src)
}
func (m *DebugDraw) XXX_Size() int {
	return m.Size()
}
func (m *DebugDraw) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugDraw.DiscardUnknown(m)
}

var xxx_messageInfo_DebugDraw proto.InternalMessageInfo

func (m *DebugDraw) GetText() []*DebugText {
	if m != nil {
		return m.Text
	}
	return nil
}

func (m *DebugDraw) GetLines() []*DebugLine {
	if m != nil {
		return m.Lines
	}
	return nil
}

func (m *DebugDraw) GetBoxes() []*DebugBox {
	if m != nil {
		return m.Boxes
	}
	return nil
}

func (m *DebugDraw) GetSpheres() []*DebugSphere {
	if m != nil {
		return m.Spheres
	}
	return nil
}

type Line struct {
	P0 *Point `protobuf:"bytes,1,opt,name=p0,proto3" json:"p0,omitempty"`
	P1 *Point `protobuf:"bytes,2,opt,name=p1,proto3" json:"p1,omitempty"`
}

func (m *Line) Reset()         { *m = Line{} }
func (m *Line) String() string { return proto.CompactTextString(m) }
func (*Line) ProtoMessage()    {}
func (*Line) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{2}
}
func (m *Line) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Line) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Line.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Line) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Line.Merge(m, src)
}
func (m *Line) XXX_Size() int {
	return m.Size()
}
func (m *Line) XXX_DiscardUnknown() {
	xxx_messageInfo_Line.DiscardUnknown(m)
}

var xxx_messageInfo_Line proto.InternalMessageInfo

func (m *Line) GetP0() *Point {
	if m != nil {
		return m.P0
	}
	return nil
}

func (m *Line) GetP1() *Point {
	if m != nil {
		return m.P1
	}
	return nil
}

type Color struct {
	R uint32 `protobuf:"varint,1,opt,name=r,proto3" json:"r,omitempty"`
	G uint32 `protobuf:"varint,2,opt,name=g,proto3" json:"g,omitempty"`
	B uint32 `protobuf:"varint,3,opt,name=b,proto3" json:"b,omitempty"`
}

func (m *Color) Reset()         { *m = Color{} }
func (m *Color) String() string { return proto.CompactTextString(m) }
func (*Color) ProtoMessage()    {}
func (*Color) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{3}
}
func (m *Color) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Color) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Color.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Color) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Color.Merge(m, src)
}
func (m *Color) XXX_Size() int {
	return m.Size()
}
func (m *Color) XXX_DiscardUnknown() {
	xxx_messageInfo_Color.DiscardUnknown(m)
}

var xxx_messageInfo_Color proto.InternalMessageInfo

func (m *Color) GetR() uint32 {
	if m != nil {
		return m.R
	}
	return 0
}

func (m *Color) GetG() uint32 {
	if m != nil {
		return m.G
	}
	return 0
}

func (m *Color) GetB() uint32 {
	if m != nil {
		return m.B
	}
	return 0
}

// Display debug text on screen.
type DebugText struct {
	Color      *Color `protobuf:"bytes,1,opt,name=color,proto3" json:"color,omitempty"`
	Text       string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	VirtualPos *Point `protobuf:"bytes,3,opt,name=virtual_pos,json=virtualPos,proto3" json:"virtual_pos,omitempty"`
	WorldPos   *Point `protobuf:"bytes,4,opt,name=world_pos,json=worldPos,proto3" json:"world_pos,omitempty"`
	Size_      uint32 `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *DebugText) Reset()         { *m = DebugText{} }
func (m *DebugText) String() string { return proto.CompactTextString(m) }
func (*DebugText) ProtoMessage()    {}
func (*DebugText) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{4}
}
func (m *DebugText) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugText) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugText.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugText) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugText.Merge(m, src)
}
func (m *DebugText) XXX_Size() int {
	return m.Size()
}
func (m *DebugText) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugText.DiscardUnknown(m)
}

var xxx_messageInfo_DebugText proto.InternalMessageInfo

func (m *DebugText) GetColor() *Color {
	if m != nil {
		return m.Color
	}
	return nil
}

func (m *DebugText) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *DebugText) GetVirtualPos() *Point {
	if m != nil {
		return m.VirtualPos
	}
	return nil
}

func (m *DebugText) GetWorldPos() *Point {
	if m != nil {
		return m.WorldPos
	}
	return nil
}

func (m *DebugText) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

// Display debug lines on screen.
type DebugLine struct {
	Color *Color `protobuf:"bytes,1,opt,name=color,proto3" json:"color,omitempty"`
	Line  *Line  `protobuf:"bytes,2,opt,name=line,proto3" json:"line,omitempty"`
}

func (m *DebugLine) Reset()         { *m = DebugLine{} }
func (m *DebugLine) String() string { return proto.CompactTextString(m) }
func (*DebugLine) ProtoMessage()    {}
func (*DebugLine) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{5}
}
func (m *DebugLine) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugLine) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugLine.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugLine) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugLine.Merge(m, src)
}
func (m *DebugLine) XXX_Size() int {
	return m.Size()
}
func (m *DebugLine) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugLine.DiscardUnknown(m)
}

var xxx_messageInfo_DebugLine proto.InternalMessageInfo

func (m *DebugLine) GetColor() *Color {
	if m != nil {
		return m.Color
	}
	return nil
}

func (m *DebugLine) GetLine() *Line {
	if m != nil {
		return m.Line
	}
	return nil
}

// Display debug boxes on screen.
type DebugBox struct {
	Color *Color `protobuf:"bytes,1,opt,name=color,proto3" json:"color,omitempty"`
	Min   *Point `protobuf:"bytes,2,opt,name=min,proto3" json:"min,omitempty"`
	Max   *Point `protobuf:"bytes,3,opt,name=max,proto3" json:"max,omitempty"`
}

func (m *DebugBox) Reset()         { *m = DebugBox{} }
func (m *DebugBox) String() string { return proto.CompactTextString(m) }
func (*DebugBox) ProtoMessage()    {}
func (*DebugBox) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{6}
}
func (m *DebugBox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugBox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugBox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugBox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugBox.Merge(m, src)
}
func (m *DebugBox) XXX_Size() int {
	return m.Size()
}
func (m *DebugBox) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugBox.DiscardUnknown(m)
}

var xxx_messageInfo_DebugBox proto.InternalMessageInfo

func (m *DebugBox) GetColor() *Color {
	if m != nil {
		return m.Color
	}
	return nil
}

func (m *DebugBox) GetMin() *Point {
	if m != nil {
		return m.Min
	}
	return nil
}

func (m *DebugBox) GetMax() *Point {
	if m != nil {
		return m.Max
	}
	return nil
}

// Display debug spheres on screen.
type DebugSphere struct {
	Color *Color  `protobuf:"bytes,1,opt,name=color,proto3" json:"color,omitempty"`
	P     *Point  `protobuf:"bytes,2,opt,name=p,proto3" json:"p,omitempty"`
	R     float32 `protobuf:"fixed32,3,opt,name=r,proto3" json:"r,omitempty"`
}

func (m *DebugSphere) Reset()         { *m = DebugSphere{} }
func (m *DebugSphere) String() string { return proto.CompactTextString(m) }
func (*DebugSphere) ProtoMessage()    {}
func (*DebugSphere) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{7}
}
func (m *DebugSphere) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugSphere) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugSphere.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugSphere) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugSphere.Merge(m, src)
}
func (m *DebugSphere) XXX_Size() int {
	return m.Size()
}
func (m *DebugSphere) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugSphere.DiscardUnknown(m)
}

var xxx_messageInfo_DebugSphere proto.InternalMessageInfo

func (m *DebugSphere) GetColor() *Color {
	if m != nil {
		return m.Color
	}
	return nil
}

func (m *DebugSphere) GetP() *Point {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *DebugSphere) GetR() float32 {
	if m != nil {
		return m.R
	}
	return 0
}

type DebugCreateUnit struct {
	UnitType UnitTypeID `protobuf:"varint,1,opt,name=unit_type,json=unitType,proto3,casttype=UnitTypeID" json:"unit_type,omitempty"`
	Owner    PlayerID   `protobuf:"varint,2,opt,name=owner,proto3,casttype=PlayerID" json:"owner,omitempty"`
	Pos      *Point2D   `protobuf:"bytes,3,opt,name=pos,proto3" json:"pos,omitempty"`
	Quantity uint32     `protobuf:"varint,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
}

func (m *DebugCreateUnit) Reset()         { *m = DebugCreateUnit{} }
func (m *DebugCreateUnit) String() string { return proto.CompactTextString(m) }
func (*DebugCreateUnit) ProtoMessage()    {}
func (*DebugCreateUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{8}
}
func (m *DebugCreateUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugCreateUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugCreateUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugCreateUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugCreateUnit.Merge(m, src)
}
func (m *DebugCreateUnit) XXX_Size() int {
	return m.Size()
}
func (m *DebugCreateUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugCreateUnit.DiscardUnknown(m)
}

var xxx_messageInfo_DebugCreateUnit proto.InternalMessageInfo

func (m *DebugCreateUnit) GetUnitType() UnitTypeID {
	if m != nil {
		return m.UnitType
	}
	return 0
}

func (m *DebugCreateUnit) GetOwner() PlayerID {
	if m != nil {
		return m.Owner
	}
	return 0
}

func (m *DebugCreateUnit) GetPos() *Point2D {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *DebugCreateUnit) GetQuantity() uint32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

type DebugKillUnit struct {
	Tag []UnitTag `protobuf:"varint,1,rep,packed,name=tag,proto3,casttype=UnitTag" json:"tag,omitempty"`
}

func (m *DebugKillUnit) Reset()         { *m = DebugKillUnit{} }
func (m *DebugKillUnit) String() string { return proto.CompactTextString(m) }
func (*DebugKillUnit) ProtoMessage()    {}
func (*DebugKillUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{9}
}
func (m *DebugKillUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugKillUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugKillUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugKillUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugKillUnit.Merge(m, src)
}
func (m *DebugKillUnit) XXX_Size() int {
	return m.Size()
}
func (m *DebugKillUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugKillUnit.DiscardUnknown(m)
}

var xxx_messageInfo_DebugKillUnit proto.InternalMessageInfo

func (m *DebugKillUnit) GetTag() []UnitTag {
	if m != nil {
		return m.Tag
	}
	return nil
}

type DebugTestProcess struct {
	Test    DebugTestProcess_Test `protobuf:"varint,1,opt,name=test,proto3,enum=SC2APIProtocol.DebugTestProcess_Test" json:"test,omitempty"`
	DelayMs int32                 `protobuf:"varint,2,opt,name=delay_ms,json=delayMs,proto3" json:"delay_ms,omitempty"`
}

func (m *DebugTestProcess) Reset()         { *m = DebugTestProcess{} }
func (m *DebugTestProcess) String() string { return proto.CompactTextString(m) }
func (*DebugTestProcess) ProtoMessage()    {}
func (*DebugTestProcess) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{10}
}
func (m *DebugTestProcess) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugTestProcess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugTestProcess.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugTestProcess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugTestProcess.Merge(m, src)
}
func (m *DebugTestProcess) XXX_Size() int {
	return m.Size()
}
func (m *DebugTestProcess) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugTestProcess.DiscardUnknown(m)
}

var xxx_messageInfo_DebugTestProcess proto.InternalMessageInfo

func (m *DebugTestProcess) GetTest() DebugTestProcess_Test {
	if m != nil {
		return m.Test
	}
	return DebugTestProcess_nil
}

func (m *DebugTestProcess) GetDelayMs() int32 {
	if m != nil {
		return m.DelayMs
	}
	return 0
}

type DebugSetScore struct {
	Score float32 `protobuf:"fixed32,1,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *DebugSetScore) Reset()         { *m = DebugSetScore{} }
func (m *DebugSetScore) String() string { return proto.CompactTextString(m) }
func (*DebugSetScore) ProtoMessage()    {}
func (*DebugSetScore) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{11}
}
func (m *DebugSetScore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugSetScore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugSetScore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugSetScore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugSetScore.Merge(m, src)
}
func (m *DebugSetScore) XXX_Size() int {
	return m.Size()
}
func (m *DebugSetScore) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugSetScore.DiscardUnknown(m)
}

var xxx_messageInfo_DebugSetScore proto.InternalMessageInfo

func (m *DebugSetScore) GetScore() float32 {
	if m != nil {
		return m.Score
	}
	return 0
}

type DebugEndGame struct {
	EndResult DebugEndGame_EndResult `protobuf:"varint,1,opt,name=end_result,json=endResult,proto3,enum=SC2APIProtocol.DebugEndGame_EndResult" json:"end_result,omitempty"`
}

func (m *DebugEndGame) Reset()         { *m = DebugEndGame{} }
func (m *DebugEndGame) String() string { return proto.CompactTextString(m) }
func (*DebugEndGame) ProtoMessage()    {}
func (*DebugEndGame) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{12}
}
func (m *DebugEndGame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugEndGame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugEndGame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugEndGame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugEndGame.Merge(m, src)
}
func (m *DebugEndGame) XXX_Size() int {
	return m.Size()
}
func (m *DebugEndGame) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugEndGame.DiscardUnknown(m)
}

var xxx_messageInfo_DebugEndGame proto.InternalMessageInfo

func (m *DebugEndGame) GetEndResult() DebugEndGame_EndResult {
	if m != nil {
		return m.EndResult
	}
	return DebugEndGame_nil
}

type DebugSetUnitValue struct {
	UnitValue DebugSetUnitValue_UnitValue `protobuf:"varint,1,opt,name=unit_value,json=unitValue,proto3,enum=SC2APIProtocol.DebugSetUnitValue_UnitValue" json:"unit_value,omitempty"`
	Value     float32                     `protobuf:"fixed32,2,opt,name=value,proto3" json:"value,omitempty"`
	UnitTag   UnitTag                     `protobuf:"varint,3,opt,name=unit_tag,json=unitTag,proto3,casttype=UnitTag" json:"unit_tag,omitempty"`
}

func (m *DebugSetUnitValue) Reset()         { *m = DebugSetUnitValue{} }
func (m *DebugSetUnitValue) String() string { return proto.CompactTextString(m) }
func (*DebugSetUnitValue) ProtoMessage()    {}
func (*DebugSetUnitValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_8d9d361be58531fb, []int{13}
}
func (m *DebugSetUnitValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugSetUnitValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugSetUnitValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugSetUnitValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugSetUnitValue.Merge(m, src)
}
func (m *DebugSetUnitValue) XXX_Size() int {
	return m.Size()
}
func (m *DebugSetUnitValue) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugSetUnitValue.DiscardUnknown(m)
}

var xxx_messageInfo_DebugSetUnitValue proto.InternalMessageInfo

func (m *DebugSetUnitValue) GetUnitValue() DebugSetUnitValue_UnitValue {
	if m != nil {
		return m.UnitValue
	}
	return DebugSetUnitValue_nil
}

func (m *DebugSetUnitValue) GetValue() float32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *DebugSetUnitValue) GetUnitTag() UnitTag {
	if m != nil {
		return m.UnitTag
	}
	return 0
}

func init() {
	proto.RegisterEnum("SC2APIProtocol.DebugGameState", DebugGameState_name, DebugGameState_value)
	proto.RegisterEnum("SC2APIProtocol.DebugTestProcess_Test", DebugTestProcess_Test_name, DebugTestProcess_Test_value)
	proto.RegisterEnum("SC2APIProtocol.DebugEndGame_EndResult", DebugEndGame_EndResult_name, DebugEndGame_EndResult_value)
	proto.RegisterEnum("SC2APIProtocol.DebugSetUnitValue_UnitValue", DebugSetUnitValue_UnitValue_name, DebugSetUnitValue_UnitValue_value)
	proto.RegisterType((*DebugCommand)(nil), "SC2APIProtocol.DebugCommand")
	proto.RegisterType((*DebugDraw)(nil), "SC2APIProtocol.DebugDraw")
	proto.RegisterType((*Line)(nil), "SC2APIProtocol.Line")
	proto.RegisterType((*Color)(nil), "SC2APIProtocol.Color")
	proto.RegisterType((*DebugText)(nil), "SC2APIProtocol.DebugText")
	proto.RegisterType((*DebugLine)(nil), "SC2APIProtocol.DebugLine")
	proto.RegisterType((*DebugBox)(nil), "SC2APIProtocol.DebugBox")
	proto.RegisterType((*DebugSphere)(nil), "SC2APIProtocol.DebugSphere")
	proto.RegisterType((*DebugCreateUnit)(nil), "SC2APIProtocol.DebugCreateUnit")
	proto.RegisterType((*DebugKillUnit)(nil), "SC2APIProtocol.DebugKillUnit")
	proto.RegisterType((*DebugTestProcess)(nil), "SC2APIProtocol.DebugTestProcess")
	proto.RegisterType((*DebugSetScore)(nil), "SC2APIProtocol.DebugSetScore")
	proto.RegisterType((*DebugEndGame)(nil), "SC2APIProtocol.DebugEndGame")
	proto.RegisterType((*DebugSetUnitValue)(nil), "SC2APIProtocol.DebugSetUnitValue")
}

func init() { proto.RegisterFile("debug.proto", fileDescriptor_8d9d361be58531fb) }

var fileDescriptor_8d9d361be58531fb = []byte{
	// 1162 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x4f, 0x8f, 0xdb, 0xc4,
	0x1b, 0xce, 0x24, 0xce, 0xc6, 0x79, 0x93, 0xec, 0xcf, 0x1d, 0xb5, 0xfa, 0xb9, 0x0b, 0xcd, 0x2e,
	0x46, 0x2d, 0x85, 0x8a, 0xb4, 0x5d, 0x54, 0xa4, 0x8a, 0x4a, 0x88, 0xec, 0xae, 0xd8, 0x96, 0x22,
	0xad, 0x66, 0x97, 0x1e, 0xb8, 0x58, 0x13, 0x7b, 0xea, 0x58, 0xb5, 0x3d, 0x66, 0x66, 0xdc, 0x24,
	0x7c, 0x03, 0x7a, 0xe2, 0x0b, 0x70, 0xe0, 0x82, 0xc4, 0x37, 0xe1, 0xc0, 0xa1, 0x82, 0x0b, 0xa7,
	0x0a, 0xb5, 0x27, 0xbe, 0x42, 0x4f, 0x68, 0xc6, 0x4e, 0xda, 0x0d, 0xd9, 0x54, 0x3d, 0xe5, 0x7d,
	0xc7, 0xcf, 0xfb, 0xf8, 0xfd, 0xf3, 0xf8, 0x9d, 0x40, 0x27, 0x64, 0xa3, 0x22, 0x1a, 0xe4, 0x82,
	0x2b, 0x8e, 0x37, 0x8f, 0xf7, 0x76, 0xbf, 0x38, 0xba, 0x7b, 0xa4, 0x9d, 0x80, 0x27, 0x5b, 0x10,
	0xf1, 0x88, 0x97, 0xcf, 0xb6, 0xba, 0x01, 0x4f, 0x53, 0x9e, 0x95, 0x9e, 0xf7, 0xc4, 0x82, 0xee,
	0xbe, 0x8e, 0xdc, 0xe3, 0x69, 0x4a, 0xb3, 0x10, 0x5f, 0x07, 0x2b, 0x14, 0x74, 0xe2, 0xa2, 0x1d,
	0x74, 0xb5, 0xb3, 0x7b, 0x71, 0x70, 0x9a, 0x69, 0x60, 0xb0, 0xfb, 0x82, 0x4e, 0x0e, 0x6b, 0xc4,
	0x00, 0xf1, 0xe7, 0x00, 0x11, 0x4d, 0x99, 0x2f, 0x15, 0x55, 0xcc, 0xad, 0xef, 0xa0, 0xab, 0x9b,
	0xbb, 0xfd, 0x95, 0x61, 0x5f, 0xd2, 0x94, 0x1d, 0x6b, 0xd4, 0x61, 0x8d, 0xb4, 0xa3, 0xb9, 0x83,
	0x87, 0xd0, 0x09, 0x04, 0xa3, 0x8a, 0xf9, 0x45, 0x16, 0x2b, 0xb7, 0x61, 0x5e, 0xbc, 0xbd, 0x92,
	0x61, 0xcf, 0xe0, 0xbe, 0xc9, 0x62, 0x75, 0x58, 0x23, 0x10, 0x2c, 0x3c, 0x7c, 0x07, 0xda, 0x8f,
	0xe2, 0x24, 0x29, 0x19, 0x2c, 0xc3, 0x70, 0x69, 0x25, 0xc3, 0x57, 0x71, 0x92, 0x54, 0xf1, 0xf6,
	0xa3, 0xca, 0xc6, 0x07, 0xd0, 0x55, 0x4c, 0x2a, 0x3f, 0x17, 0x3c, 0x60, 0x52, 0xba, 0x4d, 0x43,
	0xb0, 0xb3, 0x92, 0xe0, 0x84, 0x49, 0x75, 0x54, 0xe2, 0x0e, 0x6b, 0xa4, 0xa3, 0x5e, 0xb9, 0xf8,
	0x16, 0x34, 0x65, 0xc0, 0x05, 0x73, 0x37, 0xd6, 0x24, 0x70, 0xcc, 0xd4, 0xb1, 0x06, 0x1d, 0xd6,
	0x48, 0x89, 0xc6, 0xb7, 0xc1, 0x66, 0x59, 0xe8, 0xeb, 0x86, 0xb8, 0x2d, 0x13, 0xf9, 0xee, 0xca,
	0xc8, 0x83, 0x2c, 0xd4, 0x1d, 0x3c, 0xac, 0x91, 0x16, 0x2b, 0x4d, 0x3c, 0x04, 0xd0, 0x15, 0xfb,
	0x8f, 0x69, 0x52, 0x30, 0xd7, 0x36, 0xc1, 0xef, 0x9d, 0xf5, 0x5a, 0x5d, 0xea, 0x03, 0x0d, 0xd4,
	0xed, 0x2f, 0xe6, 0xce, 0xb0, 0x0d, 0xad, 0xa0, 0x9c, 0xbd, 0xf7, 0x07, 0x82, 0xf6, 0x62, 0xc0,
	0xf8, 0x63, 0xb0, 0x14, 0x9b, 0x2a, 0x17, 0xed, 0x34, 0xce, 0x54, 0xc2, 0x09, 0x9b, 0x2a, 0x62,
	0x60, 0xf8, 0x3a, 0x34, 0x93, 0x38, 0x63, 0xd2, 0xad, 0xaf, 0xc1, 0xdf, 0x8f, 0x33, 0x46, 0x4a,
	0x1c, 0x1e, 0x40, 0x73, 0xc4, 0xa7, 0x4c, 0xba, 0x0d, 0x13, 0xe0, 0xae, 0x0c, 0x18, 0xf2, 0x29,
	0x29, 0x61, 0xf8, 0x16, 0xb4, 0x64, 0x3e, 0x66, 0x82, 0x49, 0xd7, 0x32, 0x11, 0xef, 0xac, 0xae,
	0xd4, 0x60, 0xc8, 0x1c, 0xeb, 0x9d, 0x80, 0xa5, 0xdf, 0x8a, 0x2f, 0x43, 0x3d, 0xbf, 0x51, 0xc9,
	0xfa, 0xc2, 0x72, 0xe4, 0x11, 0x8f, 0x33, 0x45, 0xea, 0xf9, 0x0d, 0x03, 0xbb, 0x69, 0x64, 0xbc,
	0x06, 0x76, 0xd3, 0xbb, 0x09, 0xcd, 0x3d, 0x9e, 0x70, 0x81, 0xbb, 0x80, 0x84, 0x61, 0xed, 0x11,
	0x64, 0xbc, 0xc8, 0x04, 0xf7, 0x08, 0x8a, 0xb4, 0x37, 0x32, 0x7a, 0xee, 0x11, 0x34, 0xf2, 0x7e,
	0x9f, 0x77, 0x57, 0x37, 0x0d, 0x5f, 0x83, 0x66, 0xa0, 0x09, 0xce, 0xca, 0xc8, 0xb0, 0x93, 0x12,
	0x83, 0x71, 0x35, 0x0a, 0xcd, 0xdc, 0xae, 0xfa, 0xfd, 0x29, 0x74, 0x1e, 0xc7, 0x42, 0x15, 0x34,
	0xf1, 0x73, 0x2e, 0xab, 0xcf, 0xe6, 0x8c, 0x8c, 0xa1, 0x42, 0x1e, 0x71, 0x89, 0x77, 0xa1, 0x3d,
	0xe1, 0x22, 0x09, 0x4d, 0x94, 0xb5, 0x2e, 0xca, 0x36, 0x38, 0x1d, 0x83, 0xc1, 0x92, 0xf1, 0xf7,
	0xcc, 0x7c, 0x18, 0x3d, 0x62, 0x6c, 0x6f, 0x54, 0x55, 0x63, 0x9a, 0xfb, 0x56, 0xd5, 0x5c, 0x05,
	0x4b, 0x2b, 0xa0, 0x6a, 0xf2, 0xf9, 0x65, 0xac, 0xd1, 0x88, 0x41, 0x78, 0x3f, 0x20, 0xb0, 0xe7,
	0x32, 0x78, 0xbb, 0x77, 0x7c, 0x00, 0x8d, 0x34, 0xce, 0xd6, 0xcf, 0x51, 0x23, 0x0c, 0x90, 0x4e,
	0xd7, 0xb7, 0x4f, 0x23, 0xbc, 0x14, 0x3a, 0xaf, 0xe9, 0xeb, 0xed, 0xb2, 0x79, 0x1f, 0x50, 0xbe,
	0x3e, 0x17, 0x94, 0x97, 0x4a, 0xd2, 0x79, 0xd4, 0x09, 0x12, 0xde, 0xaf, 0x08, 0xfe, 0xb7, 0xb4,
	0xf3, 0xf0, 0x35, 0x30, 0xdf, 0xad, 0xaf, 0x66, 0x39, 0x2b, 0x35, 0x37, 0xdc, 0x7c, 0xf9, 0x6c,
	0x1b, 0xf4, 0xc3, 0x93, 0x59, 0xce, 0xee, 0xee, 0x13, 0xbb, 0xa8, 0x6c, 0xec, 0x41, 0x93, 0x4f,
	0x32, 0x26, 0xcc, 0x7b, 0x9b, 0xc3, 0xee, 0xcb, 0x67, 0xdb, 0xf6, 0x51, 0x42, 0x67, 0x4c, 0xdc,
	0xdd, 0x27, 0xe5, 0x23, 0xfc, 0x21, 0x34, 0x5e, 0x69, 0xe7, 0xff, 0x2b, 0x33, 0xdb, 0xdd, 0x27,
	0x1a, 0x83, 0xb7, 0xc0, 0xfe, 0xae, 0xa0, 0x99, 0x8a, 0xd5, 0xcc, 0xa8, 0xa6, 0x47, 0x16, 0xbe,
	0x37, 0x80, 0xde, 0xa9, 0xe5, 0x8a, 0x2f, 0x41, 0x43, 0xd1, 0xc8, 0x6c, 0x0e, 0x6b, 0xd8, 0x79,
	0xf9, 0x6c, 0xbb, 0x65, 0x52, 0xa4, 0x11, 0xd1, 0xe7, 0xde, 0x2f, 0x08, 0x9c, 0xe5, 0x65, 0x8a,
	0x6f, 0x6b, 0x8d, 0x4b, 0x65, 0xea, 0xda, 0xdc, 0xbd, 0xfc, 0xa6, 0xe5, 0x3b, 0xd0, 0x36, 0x31,
	0x21, 0xf8, 0x22, 0xd8, 0x21, 0x4b, 0xe8, 0xcc, 0x4f, 0x65, 0x59, 0x2d, 0x69, 0x19, 0xff, 0x6b,
	0xe9, 0xdd, 0x01, 0x4b, 0x03, 0xf1, 0x05, 0xb0, 0xf5, 0xaf, 0x9f, 0xc5, 0x89, 0x53, 0xdb, 0x6a,
	0x3d, 0xf9, 0x69, 0xa7, 0x91, 0xc5, 0x09, 0xb6, 0xc1, 0x1a, 0xd3, 0x2c, 0x72, 0x10, 0x6e, 0x43,
	0x33, 0x10, 0x54, 0x8e, 0x9d, 0xba, 0x3e, 0x64, 0xd3, 0x58, 0x39, 0x0d, 0xef, 0x72, 0x55, 0xd8,
	0x7c, 0x69, 0xe3, 0xf3, 0xf3, 0x15, 0x8f, 0xcc, 0x9c, 0x4a, 0xc7, 0xfb, 0x19, 0x55, 0x97, 0x68,
	0xb5, 0xa2, 0xf1, 0x01, 0x80, 0x5e, 0xe9, 0x82, 0xc9, 0x22, 0x99, 0x57, 0x74, 0x65, 0xdd, 0x52,
	0x1f, 0x1c, 0x64, 0x21, 0x31, 0x68, 0xd2, 0x66, 0x73, 0xd3, 0xbb, 0x07, 0xed, 0xc5, 0x39, 0xde,
	0x82, 0xde, 0xc2, 0x59, 0x2e, 0xa3, 0x07, 0xed, 0xe3, 0x42, 0x08, 0x96, 0x85, 0x4c, 0x38, 0x08,
	0x63, 0xd8, 0xdc, 0x67, 0x41, 0x42, 0x05, 0x7b, 0x10, 0x07, 0x8a, 0x8b, 0x99, 0x53, 0xf7, 0xfe,
	0x41, 0x70, 0xee, 0x3f, 0x37, 0x01, 0xbe, 0x77, 0xea, 0x02, 0x29, 0x13, 0xbd, 0xf6, 0xc6, 0x0b,
	0x64, 0xb0, 0xb0, 0x5e, 0xbb, 0x48, 0x74, 0x6f, 0x4a, 0x9a, 0x7a, 0xd9, 0x1b, 0xe3, 0xe0, 0x2b,
	0x60, 0x97, 0x9a, 0xa5, 0x91, 0xd1, 0xd9, 0x92, 0x1e, 0x5a, 0x45, 0x69, 0xe8, 0x5a, 0x5f, 0xa5,
	0xb5, 0x05, 0xbd, 0x85, 0xb3, 0x5c, 0x2b, 0xc0, 0xc6, 0x41, 0xc6, 0x44, 0x34, 0x73, 0x90, 0x9e,
	0xd4, 0xfd, 0xf8, 0x21, 0x73, 0xea, 0xb8, 0x03, 0xad, 0xe3, 0x71, 0xcc, 0x92, 0x50, 0x3a, 0x8d,
	0x8f, 0xfe, 0x44, 0xba, 0x01, 0xaf, 0xff, 0xe3, 0xc0, 0xdb, 0x80, 0x4f, 0x9f, 0x2c, 0xd3, 0x76,
	0xc1, 0x96, 0x63, 0x3e, 0xf1, 0x53, 0x9a, 0x3b, 0x08, 0x9f, 0x83, 0x5e, 0xc0, 0x33, 0x25, 0x78,
	0xe2, 0xb3, 0x8c, 0xa5, 0xb3, 0x52, 0x15, 0x0f, 0x39, 0x0f, 0x9d, 0x86, 0xb1, 0x04, 0x63, 0x8e,
	0xa5, 0x61, 0x34, 0x49, 0xf4, 0x9c, 0x79, 0x21, 0x02, 0x26, 0x9d, 0x26, 0x6e, 0x41, 0x23, 0xe2,
	0xa1, 0xb3, 0xa1, 0x09, 0xd3, 0x38, 0x63, 0x82, 0x26, 0xd2, 0x69, 0x99, 0x63, 0x2a, 0x1d, 0x5b,
	0x1f, 0x07, 0x9c, 0x27, 0x21, 0x9f, 0x64, 0x4e, 0x5b, 0x0f, 0x4e, 0xb1, 0x60, 0xec, 0x2b, 0xcd,
	0x07, 0xba, 0x8a, 0x22, 0x8f, 0x04, 0x0d, 0x99, 0xd3, 0xc1, 0x9b, 0x00, 0x0f, 0xa9, 0x54, 0xfe,
	0xa8, 0x88, 0x93, 0xd0, 0xe9, 0x0e, 0x77, 0x7e, 0x7b, 0xde, 0x47, 0x4f, 0x9f, 0xf7, 0xd1, 0xdf,
	0xcf, 0xfb, 0xe8, 0xc7, 0x17, 0xfd, 0xda, 0xd3, 0x17, 0xfd, 0xda, 0x5f, 0x2f, 0xfa, 0xb5, 0x6f,
	0x37, 0x06, 0xd7, 0x3f, 0xa3, 0x79, 0x3c, 0xda, 0x30, 0xff, 0xe9, 0x3e, 0xf9, 0x37, 0x00, 0x00,
	0xff, 0xff, 0x9b, 0x22, 0xd0, 0xcb, 0x0c, 0x0a, 0x00, 0x00,
}

func (m *DebugCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Command != nil {
		{
			size := m.Command.Size()
			i -= size
			if _, err := m.Command.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DebugCommand_Draw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugCommand_Draw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Draw != nil {
		{
			size, err := m.Draw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DebugCommand_GameState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugCommand_GameState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintDebug(dAtA, i, uint64(m.GameState))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *DebugCommand_CreateUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugCommand_CreateUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateUnit != nil {
		{
			size, err := m.CreateUnit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DebugCommand_KillUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugCommand_KillUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KillUnit != nil {
		{
			size, err := m.KillUnit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DebugCommand_TestProcess) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugCommand_TestProcess) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestProcess != nil {
		{
			size, err := m.TestProcess.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DebugCommand_Score) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugCommand_Score) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Score != nil {
		{
			size, err := m.Score.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *DebugCommand_EndGame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugCommand_EndGame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EndGame != nil {
		{
			size, err := m.EndGame.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *DebugCommand_UnitValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugCommand_UnitValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UnitValue != nil {
		{
			size, err := m.UnitValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *DebugDraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugDraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugDraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Spheres) > 0 {
		for iNdEx := len(m.Spheres) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spheres[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Boxes) > 0 {
		for iNdEx := len(m.Boxes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Boxes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Lines) > 0 {
		for iNdEx := len(m.Lines) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Lines[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Text) > 0 {
		for iNdEx := len(m.Text) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Text[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDebug(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Line) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Line) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Line) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.P1 != nil {
		{
			size, err := m.P1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.P0 != nil {
		{
			size, err := m.P0.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Color) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Color) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Color) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.B != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.B))
		i--
		dAtA[i] = 0x18
	}
	if m.G != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.G))
		i--
		dAtA[i] = 0x10
	}
	if m.R != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.R))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DebugText) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugText) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugText) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x28
	}
	if m.WorldPos != nil {
		{
			size, err := m.WorldPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.VirtualPos != nil {
		{
			size, err := m.VirtualPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintDebug(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x12
	}
	if m.Color != nil {
		{
			size, err := m.Color.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DebugLine) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugLine) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugLine) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Line != nil {
		{
			size, err := m.Line.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Color != nil {
		{
			size, err := m.Color.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DebugBox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugBox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugBox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Max != nil {
		{
			size, err := m.Max.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Min != nil {
		{
			size, err := m.Min.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Color != nil {
		{
			size, err := m.Color.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DebugSphere) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugSphere) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugSphere) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.R != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.R))))
		i--
		dAtA[i] = 0x1d
	}
	if m.P != nil {
		{
			size, err := m.P.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Color != nil {
		{
			size, err := m.Color.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DebugCreateUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugCreateUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugCreateUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Quantity != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Quantity))
		i--
		dAtA[i] = 0x20
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDebug(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Owner != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Owner))
		i--
		dAtA[i] = 0x10
	}
	if m.UnitType != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.UnitType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DebugKillUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugKillUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugKillUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tag) > 0 {
		dAtA22 := make([]byte, len(m.Tag)*10)
		var j21 int
		for _, num := range m.Tag {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintDebug(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DebugTestProcess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugTestProcess) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugTestProcess) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelayMs != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.DelayMs))
		i--
		dAtA[i] = 0x10
	}
	if m.Test != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.Test))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DebugSetScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugSetScore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugSetScore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Score != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Score))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *DebugEndGame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugEndGame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugEndGame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndResult != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.EndResult))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DebugSetUnitValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugSetUnitValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugSetUnitValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UnitTag != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.UnitTag))
		i--
		dAtA[i] = 0x18
	}
	if m.Value != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Value))))
		i--
		dAtA[i] = 0x15
	}
	if m.UnitValue != 0 {
		i = encodeVarintDebug(dAtA, i, uint64(m.UnitValue))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDebug(dAtA []byte, offset int, v uint64) int {
	offset -= sovDebug(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DebugCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Command != nil {
		n += m.Command.Size()
	}
	return n
}

func (m *DebugCommand_Draw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Draw != nil {
		l = m.Draw.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *DebugCommand_GameState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovDebug(uint64(m.GameState))
	return n
}
func (m *DebugCommand_CreateUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateUnit != nil {
		l = m.CreateUnit.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *DebugCommand_KillUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KillUnit != nil {
		l = m.KillUnit.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *DebugCommand_TestProcess) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestProcess != nil {
		l = m.TestProcess.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *DebugCommand_Score) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Score != nil {
		l = m.Score.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *DebugCommand_EndGame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndGame != nil {
		l = m.EndGame.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *DebugCommand_UnitValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnitValue != nil {
		l = m.UnitValue.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}
func (m *DebugDraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Text) > 0 {
		for _, e := range m.Text {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if len(m.Lines) > 0 {
		for _, e := range m.Lines {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if len(m.Boxes) > 0 {
		for _, e := range m.Boxes {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	if len(m.Spheres) > 0 {
		for _, e := range m.Spheres {
			l = e.Size()
			n += 1 + l + sovDebug(uint64(l))
		}
	}
	return n
}

func (m *Line) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.P0 != nil {
		l = m.P0.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.P1 != nil {
		l = m.P1.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}

func (m *Color) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.R != 0 {
		n += 1 + sovDebug(uint64(m.R))
	}
	if m.G != 0 {
		n += 1 + sovDebug(uint64(m.G))
	}
	if m.B != 0 {
		n += 1 + sovDebug(uint64(m.B))
	}
	return n
}

func (m *DebugText) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Color != nil {
		l = m.Color.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.VirtualPos != nil {
		l = m.VirtualPos.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.WorldPos != nil {
		l = m.WorldPos.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovDebug(uint64(m.Size_))
	}
	return n
}

func (m *DebugLine) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Color != nil {
		l = m.Color.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Line != nil {
		l = m.Line.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}

func (m *DebugBox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Color != nil {
		l = m.Color.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Min != nil {
		l = m.Min.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Max != nil {
		l = m.Max.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	return n
}

func (m *DebugSphere) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Color != nil {
		l = m.Color.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.P != nil {
		l = m.P.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.R != 0 {
		n += 5
	}
	return n
}

func (m *DebugCreateUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnitType != 0 {
		n += 1 + sovDebug(uint64(m.UnitType))
	}
	if m.Owner != 0 {
		n += 1 + sovDebug(uint64(m.Owner))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovDebug(uint64(l))
	}
	if m.Quantity != 0 {
		n += 1 + sovDebug(uint64(m.Quantity))
	}
	return n
}

func (m *DebugKillUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tag) > 0 {
		l = 0
		for _, e := range m.Tag {
			l += sovDebug(uint64(e))
		}
		n += 1 + sovDebug(uint64(l)) + l
	}
	return n
}

func (m *DebugTestProcess) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Test != 0 {
		n += 1 + sovDebug(uint64(m.Test))
	}
	if m.DelayMs != 0 {
		n += 1 + sovDebug(uint64(m.DelayMs))
	}
	return n
}

func (m *DebugSetScore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Score != 0 {
		n += 5
	}
	return n
}

func (m *DebugEndGame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndResult != 0 {
		n += 1 + sovDebug(uint64(m.EndResult))
	}
	return n
}

func (m *DebugSetUnitValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnitValue != 0 {
		n += 1 + sovDebug(uint64(m.UnitValue))
	}
	if m.Value != 0 {
		n += 5
	}
	if m.UnitTag != 0 {
		n += 1 + sovDebug(uint64(m.UnitTag))
	}
	return n
}

func sovDebug(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDebug(x uint64) (n int) {
	return sovDebug(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DebugCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Draw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DebugDraw{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Command = &DebugCommand_Draw{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameState", wireType)
			}
			var v DebugGameState
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= DebugGameState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Command = &DebugCommand_GameState{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateUnit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DebugCreateUnit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Command = &DebugCommand_CreateUnit{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillUnit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DebugKillUnit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Command = &DebugCommand_KillUnit{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestProcess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DebugTestProcess{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Command = &DebugCommand_TestProcess{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DebugSetScore{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Command = &DebugCommand_Score{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndGame", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DebugEndGame{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Command = &DebugCommand_EndGame{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DebugSetUnitValue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Command = &DebugCommand_UnitValue{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugDraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugDraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugDraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = append(m.Text, &DebugText{})
			if err := m.Text[len(m.Text)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lines = append(m.Lines, &DebugLine{})
			if err := m.Lines[len(m.Lines)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Boxes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Boxes = append(m.Boxes, &DebugBox{})
			if err := m.Boxes[len(m.Boxes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spheres", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spheres = append(m.Spheres, &DebugSphere{})
			if err := m.Spheres[len(m.Spheres)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Line) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Line: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Line: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P0", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.P0 == nil {
				m.P0 = &Point{}
			}
			if err := m.P0.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.P1 == nil {
				m.P1 = &Point{}
			}
			if err := m.P1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Color) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Color: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Color: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			m.R = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.R |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			m.G = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.G |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			m.B = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.B |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugText) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugText: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugText: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Color == nil {
				m.Color = &Color{}
			}
			if err := m.Color.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualPos == nil {
				m.VirtualPos = &Point{}
			}
			if err := m.VirtualPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorldPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorldPos == nil {
				m.WorldPos = &Point{}
			}
			if err := m.WorldPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugLine) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugLine: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugLine: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Color == nil {
				m.Color = &Color{}
			}
			if err := m.Color.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Line == nil {
				m.Line = &Line{}
			}
			if err := m.Line.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugBox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugBox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugBox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Color == nil {
				m.Color = &Color{}
			}
			if err := m.Color.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Min == nil {
				m.Min = &Point{}
			}
			if err := m.Min.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Max == nil {
				m.Max = &Point{}
			}
			if err := m.Max.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugSphere) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugSphere: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugSphere: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Color == nil {
				m.Color = &Color{}
			}
			if err := m.Color.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.P == nil {
				m.P = &Point{}
			}
			if err := m.P.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.R = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugCreateUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugCreateUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugCreateUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			m.UnitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitType |= UnitTypeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= PlayerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebug
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDebug
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Point2D{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugKillUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugKillUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugKillUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v UnitTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDebug
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= UnitTag(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Tag = append(m.Tag, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDebug
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDebug
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDebug
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Tag) == 0 {
					m.Tag = make([]UnitTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UnitTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDebug
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= UnitTag(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Tag = append(m.Tag, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugTestProcess) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugTestProcess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugTestProcess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Test", wireType)
			}
			m.Test = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Test |= DebugTestProcess_Test(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayMs", wireType)
			}
			m.DelayMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayMs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugSetScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugSetScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugSetScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Score = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugEndGame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugEndGame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugEndGame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndResult", wireType)
			}
			m.EndResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndResult |= DebugEndGame_EndResult(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugSetUnitValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugSetUnitValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugSetUnitValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitValue", wireType)
			}
			m.UnitValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitValue |= DebugSetUnitValue_UnitValue(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Value = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTag", wireType)
			}
			m.UnitTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitTag |= UnitTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDebug(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDebug
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDebug(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDebug
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDebug
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDebug
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDebug
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDebug
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDebug        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDebug          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDebug = fmt.Errorf("proto: unexpected end of group")
)
