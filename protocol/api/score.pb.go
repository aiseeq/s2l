// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: score.proto

package api

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Score_ScoreType int32

const (
	Score_nil        Score_ScoreType = 0
	Score_Curriculum Score_ScoreType = 1
	Score_Melee      Score_ScoreType = 2
)

var Score_ScoreType_name = map[int32]string{
	0: "ScoreType_nil",
	1: "Curriculum",
	2: "Melee",
}

var Score_ScoreType_value = map[string]int32{
	"ScoreType_nil": 0,
	"Curriculum":    1,
	"Melee":         2,
}

func (x Score_ScoreType) String() string {
	return proto.EnumName(Score_ScoreType_name, int32(x))
}

func (Score_ScoreType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c51f80048ffc9fcd, []int{0, 0}
}

type Score struct {
	ScoreType    Score_ScoreType `protobuf:"varint,6,opt,name=score_type,json=scoreType,proto3,enum=SC2APIProtocol.Score_ScoreType" json:"score_type,omitempty"`
	Score        int32           `protobuf:"varint,7,opt,name=score,proto3" json:"score,omitempty"`
	ScoreDetails *ScoreDetails   `protobuf:"bytes,8,opt,name=score_details,json=scoreDetails,proto3" json:"score_details,omitempty"`
}

func (m *Score) Reset()         { *m = Score{} }
func (m *Score) String() string { return proto.CompactTextString(m) }
func (*Score) ProtoMessage()    {}
func (*Score) Descriptor() ([]byte, []int) {
	return fileDescriptor_c51f80048ffc9fcd, []int{0}
}
func (m *Score) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Score) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Score.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Score) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Score.Merge(m, src)
}
func (m *Score) XXX_Size() int {
	return m.Size()
}
func (m *Score) XXX_DiscardUnknown() {
	xxx_messageInfo_Score.DiscardUnknown(m)
}

var xxx_messageInfo_Score proto.InternalMessageInfo

func (m *Score) GetScoreType() Score_ScoreType {
	if m != nil {
		return m.ScoreType
	}
	return Score_nil
}

func (m *Score) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *Score) GetScoreDetails() *ScoreDetails {
	if m != nil {
		return m.ScoreDetails
	}
	return nil
}

type CategoryScoreDetails struct {
	None       float32 `protobuf:"fixed32,1,opt,name=none,proto3" json:"none,omitempty"`
	Army       float32 `protobuf:"fixed32,2,opt,name=army,proto3" json:"army,omitempty"`
	Economy    float32 `protobuf:"fixed32,3,opt,name=economy,proto3" json:"economy,omitempty"`
	Technology float32 `protobuf:"fixed32,4,opt,name=technology,proto3" json:"technology,omitempty"`
	Upgrade    float32 `protobuf:"fixed32,5,opt,name=upgrade,proto3" json:"upgrade,omitempty"`
}

func (m *CategoryScoreDetails) Reset()         { *m = CategoryScoreDetails{} }
func (m *CategoryScoreDetails) String() string { return proto.CompactTextString(m) }
func (*CategoryScoreDetails) ProtoMessage()    {}
func (*CategoryScoreDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_c51f80048ffc9fcd, []int{1}
}
func (m *CategoryScoreDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CategoryScoreDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CategoryScoreDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CategoryScoreDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CategoryScoreDetails.Merge(m, src)
}
func (m *CategoryScoreDetails) XXX_Size() int {
	return m.Size()
}
func (m *CategoryScoreDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_CategoryScoreDetails.DiscardUnknown(m)
}

var xxx_messageInfo_CategoryScoreDetails proto.InternalMessageInfo

func (m *CategoryScoreDetails) GetNone() float32 {
	if m != nil {
		return m.None
	}
	return 0
}

func (m *CategoryScoreDetails) GetArmy() float32 {
	if m != nil {
		return m.Army
	}
	return 0
}

func (m *CategoryScoreDetails) GetEconomy() float32 {
	if m != nil {
		return m.Economy
	}
	return 0
}

func (m *CategoryScoreDetails) GetTechnology() float32 {
	if m != nil {
		return m.Technology
	}
	return 0
}

func (m *CategoryScoreDetails) GetUpgrade() float32 {
	if m != nil {
		return m.Upgrade
	}
	return 0
}

type VitalScoreDetails struct {
	Life    float32 `protobuf:"fixed32,1,opt,name=life,proto3" json:"life,omitempty"`
	Shields float32 `protobuf:"fixed32,2,opt,name=shields,proto3" json:"shields,omitempty"`
	Energy  float32 `protobuf:"fixed32,3,opt,name=energy,proto3" json:"energy,omitempty"`
}

func (m *VitalScoreDetails) Reset()         { *m = VitalScoreDetails{} }
func (m *VitalScoreDetails) String() string { return proto.CompactTextString(m) }
func (*VitalScoreDetails) ProtoMessage()    {}
func (*VitalScoreDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_c51f80048ffc9fcd, []int{2}
}
func (m *VitalScoreDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VitalScoreDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VitalScoreDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VitalScoreDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VitalScoreDetails.Merge(m, src)
}
func (m *VitalScoreDetails) XXX_Size() int {
	return m.Size()
}
func (m *VitalScoreDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_VitalScoreDetails.DiscardUnknown(m)
}

var xxx_messageInfo_VitalScoreDetails proto.InternalMessageInfo

func (m *VitalScoreDetails) GetLife() float32 {
	if m != nil {
		return m.Life
	}
	return 0
}

func (m *VitalScoreDetails) GetShields() float32 {
	if m != nil {
		return m.Shields
	}
	return 0
}

func (m *VitalScoreDetails) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

type ScoreDetails struct {
	IdleProductionTime     float32               `protobuf:"fixed32,1,opt,name=idle_production_time,json=idleProductionTime,proto3" json:"idle_production_time,omitempty"`
	IdleWorkerTime         float32               `protobuf:"fixed32,2,opt,name=idle_worker_time,json=idleWorkerTime,proto3" json:"idle_worker_time,omitempty"`
	TotalValueUnits        float32               `protobuf:"fixed32,3,opt,name=total_value_units,json=totalValueUnits,proto3" json:"total_value_units,omitempty"`
	TotalValueStructures   float32               `protobuf:"fixed32,4,opt,name=total_value_structures,json=totalValueStructures,proto3" json:"total_value_structures,omitempty"`
	KilledValueUnits       float32               `protobuf:"fixed32,5,opt,name=killed_value_units,json=killedValueUnits,proto3" json:"killed_value_units,omitempty"`
	KilledValueStructures  float32               `protobuf:"fixed32,6,opt,name=killed_value_structures,json=killedValueStructures,proto3" json:"killed_value_structures,omitempty"`
	CollectedMinerals      float32               `protobuf:"fixed32,7,opt,name=collected_minerals,json=collectedMinerals,proto3" json:"collected_minerals,omitempty"`
	CollectedVespene       float32               `protobuf:"fixed32,8,opt,name=collected_vespene,json=collectedVespene,proto3" json:"collected_vespene,omitempty"`
	CollectionRateMinerals float32               `protobuf:"fixed32,9,opt,name=collection_rate_minerals,json=collectionRateMinerals,proto3" json:"collection_rate_minerals,omitempty"`
	CollectionRateVespene  float32               `protobuf:"fixed32,10,opt,name=collection_rate_vespene,json=collectionRateVespene,proto3" json:"collection_rate_vespene,omitempty"`
	SpentMinerals          float32               `protobuf:"fixed32,11,opt,name=spent_minerals,json=spentMinerals,proto3" json:"spent_minerals,omitempty"`
	SpentVespene           float32               `protobuf:"fixed32,12,opt,name=spent_vespene,json=spentVespene,proto3" json:"spent_vespene,omitempty"`
	FoodUsed               *CategoryScoreDetails `protobuf:"bytes,13,opt,name=food_used,json=foodUsed,proto3" json:"food_used,omitempty"`
	KilledMinerals         *CategoryScoreDetails `protobuf:"bytes,14,opt,name=killed_minerals,json=killedMinerals,proto3" json:"killed_minerals,omitempty"`
	KilledVespene          *CategoryScoreDetails `protobuf:"bytes,15,opt,name=killed_vespene,json=killedVespene,proto3" json:"killed_vespene,omitempty"`
	LostMinerals           *CategoryScoreDetails `protobuf:"bytes,16,opt,name=lost_minerals,json=lostMinerals,proto3" json:"lost_minerals,omitempty"`
	LostVespene            *CategoryScoreDetails `protobuf:"bytes,17,opt,name=lost_vespene,json=lostVespene,proto3" json:"lost_vespene,omitempty"`
	FriendlyFireMinerals   *CategoryScoreDetails `protobuf:"bytes,18,opt,name=friendly_fire_minerals,json=friendlyFireMinerals,proto3" json:"friendly_fire_minerals,omitempty"`
	FriendlyFireVespene    *CategoryScoreDetails `protobuf:"bytes,19,opt,name=friendly_fire_vespene,json=friendlyFireVespene,proto3" json:"friendly_fire_vespene,omitempty"`
	UsedMinerals           *CategoryScoreDetails `protobuf:"bytes,20,opt,name=used_minerals,json=usedMinerals,proto3" json:"used_minerals,omitempty"`
	UsedVespene            *CategoryScoreDetails `protobuf:"bytes,21,opt,name=used_vespene,json=usedVespene,proto3" json:"used_vespene,omitempty"`
	TotalUsedMinerals      *CategoryScoreDetails `protobuf:"bytes,22,opt,name=total_used_minerals,json=totalUsedMinerals,proto3" json:"total_used_minerals,omitempty"`
	TotalUsedVespene       *CategoryScoreDetails `protobuf:"bytes,23,opt,name=total_used_vespene,json=totalUsedVespene,proto3" json:"total_used_vespene,omitempty"`
	TotalDamageDealt       *VitalScoreDetails    `protobuf:"bytes,24,opt,name=total_damage_dealt,json=totalDamageDealt,proto3" json:"total_damage_dealt,omitempty"`
	TotalDamageTaken       *VitalScoreDetails    `protobuf:"bytes,25,opt,name=total_damage_taken,json=totalDamageTaken,proto3" json:"total_damage_taken,omitempty"`
	TotalHealed            *VitalScoreDetails    `protobuf:"bytes,26,opt,name=total_healed,json=totalHealed,proto3" json:"total_healed,omitempty"`
	CurrentApm             float32               `protobuf:"fixed32,27,opt,name=current_apm,json=currentApm,proto3" json:"current_apm,omitempty"`
	CurrentEffectiveApm    float32               `protobuf:"fixed32,28,opt,name=current_effective_apm,json=currentEffectiveApm,proto3" json:"current_effective_apm,omitempty"`
}

func (m *ScoreDetails) Reset()         { *m = ScoreDetails{} }
func (m *ScoreDetails) String() string { return proto.CompactTextString(m) }
func (*ScoreDetails) ProtoMessage()    {}
func (*ScoreDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_c51f80048ffc9fcd, []int{3}
}
func (m *ScoreDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScoreDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScoreDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScoreDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScoreDetails.Merge(m, src)
}
func (m *ScoreDetails) XXX_Size() int {
	return m.Size()
}
func (m *ScoreDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ScoreDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ScoreDetails proto.InternalMessageInfo

func (m *ScoreDetails) GetIdleProductionTime() float32 {
	if m != nil {
		return m.IdleProductionTime
	}
	return 0
}

func (m *ScoreDetails) GetIdleWorkerTime() float32 {
	if m != nil {
		return m.IdleWorkerTime
	}
	return 0
}

func (m *ScoreDetails) GetTotalValueUnits() float32 {
	if m != nil {
		return m.TotalValueUnits
	}
	return 0
}

func (m *ScoreDetails) GetTotalValueStructures() float32 {
	if m != nil {
		return m.TotalValueStructures
	}
	return 0
}

func (m *ScoreDetails) GetKilledValueUnits() float32 {
	if m != nil {
		return m.KilledValueUnits
	}
	return 0
}

func (m *ScoreDetails) GetKilledValueStructures() float32 {
	if m != nil {
		return m.KilledValueStructures
	}
	return 0
}

func (m *ScoreDetails) GetCollectedMinerals() float32 {
	if m != nil {
		return m.CollectedMinerals
	}
	return 0
}

func (m *ScoreDetails) GetCollectedVespene() float32 {
	if m != nil {
		return m.CollectedVespene
	}
	return 0
}

func (m *ScoreDetails) GetCollectionRateMinerals() float32 {
	if m != nil {
		return m.CollectionRateMinerals
	}
	return 0
}

func (m *ScoreDetails) GetCollectionRateVespene() float32 {
	if m != nil {
		return m.CollectionRateVespene
	}
	return 0
}

func (m *ScoreDetails) GetSpentMinerals() float32 {
	if m != nil {
		return m.SpentMinerals
	}
	return 0
}

func (m *ScoreDetails) GetSpentVespene() float32 {
	if m != nil {
		return m.SpentVespene
	}
	return 0
}

func (m *ScoreDetails) GetFoodUsed() *CategoryScoreDetails {
	if m != nil {
		return m.FoodUsed
	}
	return nil
}

func (m *ScoreDetails) GetKilledMinerals() *CategoryScoreDetails {
	if m != nil {
		return m.KilledMinerals
	}
	return nil
}

func (m *ScoreDetails) GetKilledVespene() *CategoryScoreDetails {
	if m != nil {
		return m.KilledVespene
	}
	return nil
}

func (m *ScoreDetails) GetLostMinerals() *CategoryScoreDetails {
	if m != nil {
		return m.LostMinerals
	}
	return nil
}

func (m *ScoreDetails) GetLostVespene() *CategoryScoreDetails {
	if m != nil {
		return m.LostVespene
	}
	return nil
}

func (m *ScoreDetails) GetFriendlyFireMinerals() *CategoryScoreDetails {
	if m != nil {
		return m.FriendlyFireMinerals
	}
	return nil
}

func (m *ScoreDetails) GetFriendlyFireVespene() *CategoryScoreDetails {
	if m != nil {
		return m.FriendlyFireVespene
	}
	return nil
}

func (m *ScoreDetails) GetUsedMinerals() *CategoryScoreDetails {
	if m != nil {
		return m.UsedMinerals
	}
	return nil
}

func (m *ScoreDetails) GetUsedVespene() *CategoryScoreDetails {
	if m != nil {
		return m.UsedVespene
	}
	return nil
}

func (m *ScoreDetails) GetTotalUsedMinerals() *CategoryScoreDetails {
	if m != nil {
		return m.TotalUsedMinerals
	}
	return nil
}

func (m *ScoreDetails) GetTotalUsedVespene() *CategoryScoreDetails {
	if m != nil {
		return m.TotalUsedVespene
	}
	return nil
}

func (m *ScoreDetails) GetTotalDamageDealt() *VitalScoreDetails {
	if m != nil {
		return m.TotalDamageDealt
	}
	return nil
}

func (m *ScoreDetails) GetTotalDamageTaken() *VitalScoreDetails {
	if m != nil {
		return m.TotalDamageTaken
	}
	return nil
}

func (m *ScoreDetails) GetTotalHealed() *VitalScoreDetails {
	if m != nil {
		return m.TotalHealed
	}
	return nil
}

func (m *ScoreDetails) GetCurrentApm() float32 {
	if m != nil {
		return m.CurrentApm
	}
	return 0
}

func (m *ScoreDetails) GetCurrentEffectiveApm() float32 {
	if m != nil {
		return m.CurrentEffectiveApm
	}
	return 0
}

func init() {
	proto.RegisterEnum("SC2APIProtocol.Score_ScoreType", Score_ScoreType_name, Score_ScoreType_value)
	proto.RegisterType((*Score)(nil), "SC2APIProtocol.Score")
	proto.RegisterType((*CategoryScoreDetails)(nil), "SC2APIProtocol.CategoryScoreDetails")
	proto.RegisterType((*VitalScoreDetails)(nil), "SC2APIProtocol.VitalScoreDetails")
	proto.RegisterType((*ScoreDetails)(nil), "SC2APIProtocol.ScoreDetails")
}

func init() { proto.RegisterFile("score.proto", fileDescriptor_c51f80048ffc9fcd) }

var fileDescriptor_c51f80048ffc9fcd = []byte{
	// 892 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xae, 0xb3, 0x9b, 0x74, 0x73, 0xf2, 0xd3, 0x74, 0x9a, 0xa6, 0xa6, 0xac, 0xb2, 0x21, 0x80,
	0x14, 0xf1, 0x53, 0x50, 0x41, 0x2b, 0x24, 0x24, 0xa4, 0x6c, 0xcb, 0xcf, 0x0a, 0x55, 0x54, 0xe9,
	0x0f, 0xb0, 0x37, 0x96, 0xb1, 0x4f, 0xd2, 0x51, 0xc7, 0x1e, 0x6b, 0x3c, 0x2e, 0xca, 0x2b, 0x70,
	0x85, 0xb8, 0xe7, 0x7d, 0xb8, 0xdc, 0x4b, 0x2e, 0x51, 0xcb, 0x03, 0xf0, 0x08, 0x68, 0x66, 0x3c,
	0x8e, 0xd3, 0xdd, 0x0b, 0xcc, 0x4d, 0x34, 0xe7, 0x3b, 0xe7, 0xfb, 0xce, 0xe7, 0xe3, 0xf1, 0x4c,
	0xa0, 0x95, 0x06, 0x5c, 0xe0, 0x41, 0x22, 0xb8, 0xe4, 0xa4, 0x7b, 0x76, 0x74, 0x38, 0x3d, 0x7d,
	0x7e, 0xaa, 0x82, 0x80, 0xb3, 0x7d, 0x58, 0xf0, 0x05, 0x37, 0xb9, 0xf1, 0xdf, 0x0e, 0xd4, 0xcf,
	0x54, 0x2d, 0xf9, 0x02, 0x40, 0x93, 0x3c, 0xb9, 0x4c, 0xd0, 0x6d, 0x8c, 0x9c, 0x49, 0xf7, 0xf0,
	0xc9, 0xc1, 0x3a, 0xf5, 0x40, 0x97, 0x9a, 0xdf, 0xf3, 0x65, 0x82, 0xb3, 0x66, 0x6a, 0x97, 0xa4,
	0x0f, 0x75, 0x1d, 0xb8, 0x9b, 0x23, 0x67, 0x52, 0x9f, 0x99, 0x80, 0x4c, 0xa1, 0x63, 0x54, 0x43,
	0x94, 0x3e, 0x65, 0xa9, 0xfb, 0x68, 0xe4, 0x4c, 0x5a, 0x87, 0x8f, 0x5f, 0x2b, 0x7c, 0x6c, 0x6a,
	0x66, 0xed, 0xb4, 0x14, 0x8d, 0x9f, 0x41, 0xb3, 0x68, 0x48, 0xf6, 0xa1, 0x53, 0x04, 0x5e, 0x4c,
	0x59, 0x6f, 0x63, 0x7f, 0xf3, 0x97, 0xdf, 0x47, 0x0f, 0x62, 0xca, 0x48, 0x17, 0xe0, 0x28, 0x13,
	0x82, 0x06, 0x19, 0xcb, 0xa2, 0x9e, 0x43, 0x9a, 0x50, 0x3f, 0x41, 0x86, 0xd8, 0xab, 0x8d, 0x7f,
	0x73, 0xa0, 0x7f, 0xe4, 0x4b, 0x5c, 0x70, 0xb1, 0x2c, 0xb7, 0x22, 0x04, 0x1e, 0xc6, 0x3c, 0x46,
	0xd7, 0x19, 0x39, 0x93, 0xda, 0x4c, 0xaf, 0x15, 0xe6, 0x8b, 0x68, 0xe9, 0xd6, 0x0c, 0xa6, 0xd6,
	0xc4, 0x85, 0x4d, 0x0c, 0x78, 0xcc, 0xa3, 0xa5, 0xfb, 0x40, 0xc3, 0x36, 0x24, 0x43, 0x00, 0x89,
	0xc1, 0x55, 0xcc, 0x19, 0x5f, 0x2c, 0xdd, 0x87, 0x3a, 0x59, 0x42, 0x14, 0x33, 0x4b, 0x16, 0xc2,
	0x0f, 0xd1, 0xad, 0x1b, 0x66, 0x1e, 0x8e, 0x7f, 0x84, 0xed, 0x4b, 0x2a, 0x7d, 0x76, 0xdf, 0x10,
	0xa3, 0xf3, 0xc2, 0x90, 0x5a, 0x2b, 0x89, 0xf4, 0x8a, 0x22, 0x0b, 0xd3, 0xdc, 0x93, 0x0d, 0xc9,
	0x00, 0x1a, 0x18, 0xa3, 0x58, 0x58, 0x57, 0x79, 0x34, 0xfe, 0xa7, 0x03, 0xed, 0x35, 0xd9, 0x8f,
	0xa1, 0x4f, 0x43, 0x86, 0x5e, 0x22, 0x78, 0x98, 0x05, 0x92, 0xf2, 0xd8, 0x93, 0x34, 0xb2, 0x6d,
	0x88, 0xca, 0x9d, 0x16, 0xa9, 0x73, 0x1a, 0x21, 0x99, 0x40, 0x4f, 0x33, 0x7e, 0xe6, 0xe2, 0x1a,
	0x85, 0xa9, 0x36, 0xdd, 0xbb, 0x0a, 0xff, 0x5e, 0xc3, 0xba, 0xf2, 0x3d, 0xd8, 0x96, 0x5c, 0xfa,
	0xcc, 0xbb, 0xf1, 0x59, 0x86, 0x5e, 0x16, 0x53, 0x99, 0xe6, 0x7e, 0xb6, 0x74, 0xe2, 0x52, 0xe1,
	0x17, 0x0a, 0x26, 0x9f, 0xc2, 0xa0, 0x5c, 0x9b, 0x4a, 0x91, 0x05, 0x32, 0x13, 0x98, 0xe6, 0x93,
	0xeb, 0xaf, 0x08, 0x67, 0x45, 0x8e, 0x7c, 0x00, 0xe4, 0x9a, 0x32, 0x86, 0xe1, 0x5a, 0x0b, 0x33,
	0xce, 0x9e, 0xc9, 0x94, 0x7a, 0x3c, 0x85, 0xbd, 0xb5, 0xea, 0x52, 0x93, 0x86, 0xa6, 0xec, 0x96,
	0x28, 0xa5, 0x2e, 0x1f, 0x02, 0x09, 0x38, 0x63, 0x18, 0x48, 0x0c, 0xbd, 0x88, 0xc6, 0x28, 0x7c,
	0x96, 0xea, 0xed, 0x5c, 0x9b, 0x6d, 0x17, 0x99, 0x93, 0x3c, 0x41, 0xde, 0x87, 0x15, 0xe8, 0xdd,
	0x60, 0x9a, 0x60, 0x8c, 0x7a, 0x7b, 0xd7, 0x66, 0xbd, 0x22, 0x71, 0x69, 0x70, 0xf2, 0x19, 0xb8,
	0x39, 0xa6, 0x46, 0x2f, 0x7c, 0x89, 0xab, 0x0e, 0x4d, 0xcd, 0x19, 0xac, 0xf2, 0x33, 0x5f, 0x62,
	0xd1, 0xe6, 0x29, 0xec, 0xdd, 0x67, 0xda, 0x66, 0x60, 0x9e, 0x66, 0x9d, 0x68, 0x3b, 0xbe, 0x0b,
	0x5d, 0xb5, 0x90, 0xab, 0x3e, 0x2d, 0x5d, 0xde, 0xd1, 0x68, 0x21, 0xff, 0x36, 0x18, 0xa0, 0x10,
	0x6d, 0xeb, 0xaa, 0xb6, 0x06, 0xad, 0xd6, 0x14, 0x9a, 0x73, 0xce, 0x43, 0x2f, 0x4b, 0x31, 0x74,
	0x3b, 0xfa, 0x0b, 0x7e, 0xe7, 0xfe, 0x17, 0xfc, 0xba, 0xcf, 0x6b, 0xf6, 0x48, 0xd1, 0x2e, 0x52,
	0x0c, 0xc9, 0x09, 0x6c, 0xe5, 0x2f, 0xa5, 0xf0, 0xd3, 0xad, 0x20, 0xd4, 0x35, 0xe4, 0xc2, 0xf6,
	0xb7, 0xd0, 0xb5, 0xef, 0x38, 0xf7, 0xbd, 0x55, 0x41, 0xad, 0x93, 0x6f, 0x80, 0xfc, 0xf1, 0x9e,
	0x43, 0x87, 0xf1, 0xb4, 0x34, 0xa9, 0x5e, 0x05, 0xad, 0xb6, 0xa2, 0x16, 0xbe, 0xbe, 0x06, 0x1d,
	0x17, 0xae, 0xb6, 0x2b, 0x28, 0xb5, 0x14, 0xd3, 0x7a, 0x7a, 0x01, 0x83, 0xb9, 0xa0, 0x18, 0x87,
	0x6c, 0xe9, 0xcd, 0xa9, 0x28, 0x6d, 0x17, 0x52, 0x41, 0xb2, 0x6f, 0x35, 0xbe, 0xa2, 0x62, 0xb5,
	0xa5, 0x7e, 0x80, 0xdd, 0x75, 0x6d, 0xeb, 0x76, 0xa7, 0x82, 0xf4, 0x4e, 0x59, 0xba, 0x34, 0x49,
	0xb5, 0x47, 0x56, 0x66, 0xfb, 0x55, 0x26, 0xa9, 0xa8, 0xe5, 0x49, 0x6a, 0x29, 0xeb, 0x6d, 0xb7,
	0xca, 0x24, 0x15, 0xd3, 0x7a, 0x3a, 0x87, 0x1d, 0x73, 0xe4, 0xac, 0x3b, 0x1b, 0x54, 0xd0, 0x33,
	0xe7, 0xdb, 0x45, 0xd9, 0xde, 0x0c, 0x48, 0x49, 0xd5, 0x9a, 0xdc, 0xab, 0x20, 0xda, 0x2b, 0x44,
	0xad, 0xd3, 0xef, 0xac, 0x66, 0xe8, 0x47, 0xfe, 0x42, 0xdd, 0x99, 0x3e, 0x93, 0xae, 0xab, 0x35,
	0xdf, 0xba, 0xaf, 0xf9, 0xca, 0xd5, 0x91, 0x0b, 0x1e, 0x6b, 0xee, 0xb1, 0xa2, 0xbe, 0x22, 0x28,
	0xfd, 0x6b, 0x8c, 0xdd, 0x37, 0xfe, 0x8f, 0xe0, 0xb9, 0xa2, 0x92, 0x63, 0x68, 0x1b, 0xc1, 0x2b,
	0xf4, 0x19, 0x86, 0xee, 0xfe, 0x7f, 0x95, 0x6a, 0x69, 0xda, 0x37, 0x9a, 0x45, 0x9e, 0x40, 0x2b,
	0xc8, 0x84, 0x50, 0xa7, 0x8e, 0x9f, 0x44, 0xee, 0x9b, 0xe6, 0xce, 0xcc, 0xa1, 0x69, 0x12, 0x91,
	0x43, 0xd8, 0xb5, 0x05, 0x38, 0x9f, 0xab, 0xb3, 0xed, 0x06, 0x75, 0xe9, 0x63, 0x5d, 0xba, 0x93,
	0x27, 0xbf, 0xb4, 0xb9, 0x69, 0x12, 0x3d, 0x1b, 0xfd, 0x71, 0x3b, 0x74, 0x5e, 0xde, 0x0e, 0x9d,
	0xbf, 0x6e, 0x87, 0xce, 0xaf, 0x77, 0xc3, 0x8d, 0x97, 0x77, 0xc3, 0x8d, 0x3f, 0xef, 0x86, 0x1b,
	0x2f, 0x1a, 0x07, 0x1f, 0x7d, 0xee, 0x27, 0xf4, 0xa7, 0x86, 0xfe, 0xcb, 0xf3, 0xc9, 0xbf, 0x01,
	0x00, 0x00, 0xff, 0xff, 0xdc, 0xde, 0x6b, 0x8f, 0x1d, 0x09, 0x00, 0x00,
}

func (m *Score) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Score) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Score) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ScoreDetails != nil {
		{
			size, err := m.ScoreDetails.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Score != 0 {
		i = encodeVarintScore(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x38
	}
	if m.ScoreType != 0 {
		i = encodeVarintScore(dAtA, i, uint64(m.ScoreType))
		i--
		dAtA[i] = 0x30
	}
	return len(dAtA) - i, nil
}

func (m *CategoryScoreDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CategoryScoreDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CategoryScoreDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Upgrade != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Upgrade))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Technology != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Technology))))
		i--
		dAtA[i] = 0x25
	}
	if m.Economy != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Economy))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Army != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Army))))
		i--
		dAtA[i] = 0x15
	}
	if m.None != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.None))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *VitalScoreDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VitalScoreDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VitalScoreDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Energy != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Shields != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Shields))))
		i--
		dAtA[i] = 0x15
	}
	if m.Life != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Life))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *ScoreDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScoreDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScoreDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentEffectiveApm != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CurrentEffectiveApm))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe5
	}
	if m.CurrentApm != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CurrentApm))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xdd
	}
	if m.TotalHealed != nil {
		{
			size, err := m.TotalHealed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.TotalDamageTaken != nil {
		{
			size, err := m.TotalDamageTaken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.TotalDamageDealt != nil {
		{
			size, err := m.TotalDamageDealt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.TotalUsedVespene != nil {
		{
			size, err := m.TotalUsedVespene.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.TotalUsedMinerals != nil {
		{
			size, err := m.TotalUsedMinerals.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.UsedVespene != nil {
		{
			size, err := m.UsedVespene.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.UsedMinerals != nil {
		{
			size, err := m.UsedMinerals.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.FriendlyFireVespene != nil {
		{
			size, err := m.FriendlyFireVespene.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.FriendlyFireMinerals != nil {
		{
			size, err := m.FriendlyFireMinerals.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.LostVespene != nil {
		{
			size, err := m.LostVespene.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.LostMinerals != nil {
		{
			size, err := m.LostMinerals.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.KilledVespene != nil {
		{
			size, err := m.KilledVespene.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.KilledMinerals != nil {
		{
			size, err := m.KilledMinerals.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.FoodUsed != nil {
		{
			size, err := m.FoodUsed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.SpentVespene != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SpentVespene))))
		i--
		dAtA[i] = 0x65
	}
	if m.SpentMinerals != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SpentMinerals))))
		i--
		dAtA[i] = 0x5d
	}
	if m.CollectionRateVespene != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CollectionRateVespene))))
		i--
		dAtA[i] = 0x55
	}
	if m.CollectionRateMinerals != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CollectionRateMinerals))))
		i--
		dAtA[i] = 0x4d
	}
	if m.CollectedVespene != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CollectedVespene))))
		i--
		dAtA[i] = 0x45
	}
	if m.CollectedMinerals != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CollectedMinerals))))
		i--
		dAtA[i] = 0x3d
	}
	if m.KilledValueStructures != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.KilledValueStructures))))
		i--
		dAtA[i] = 0x35
	}
	if m.KilledValueUnits != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.KilledValueUnits))))
		i--
		dAtA[i] = 0x2d
	}
	if m.TotalValueStructures != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TotalValueStructures))))
		i--
		dAtA[i] = 0x25
	}
	if m.TotalValueUnits != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TotalValueUnits))))
		i--
		dAtA[i] = 0x1d
	}
	if m.IdleWorkerTime != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.IdleWorkerTime))))
		i--
		dAtA[i] = 0x15
	}
	if m.IdleProductionTime != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.IdleProductionTime))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func encodeVarintScore(dAtA []byte, offset int, v uint64) int {
	offset -= sovScore(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Score) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScoreType != 0 {
		n += 1 + sovScore(uint64(m.ScoreType))
	}
	if m.Score != 0 {
		n += 1 + sovScore(uint64(m.Score))
	}
	if m.ScoreDetails != nil {
		l = m.ScoreDetails.Size()
		n += 1 + l + sovScore(uint64(l))
	}
	return n
}

func (m *CategoryScoreDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.None != 0 {
		n += 5
	}
	if m.Army != 0 {
		n += 5
	}
	if m.Economy != 0 {
		n += 5
	}
	if m.Technology != 0 {
		n += 5
	}
	if m.Upgrade != 0 {
		n += 5
	}
	return n
}

func (m *VitalScoreDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Life != 0 {
		n += 5
	}
	if m.Shields != 0 {
		n += 5
	}
	if m.Energy != 0 {
		n += 5
	}
	return n
}

func (m *ScoreDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdleProductionTime != 0 {
		n += 5
	}
	if m.IdleWorkerTime != 0 {
		n += 5
	}
	if m.TotalValueUnits != 0 {
		n += 5
	}
	if m.TotalValueStructures != 0 {
		n += 5
	}
	if m.KilledValueUnits != 0 {
		n += 5
	}
	if m.KilledValueStructures != 0 {
		n += 5
	}
	if m.CollectedMinerals != 0 {
		n += 5
	}
	if m.CollectedVespene != 0 {
		n += 5
	}
	if m.CollectionRateMinerals != 0 {
		n += 5
	}
	if m.CollectionRateVespene != 0 {
		n += 5
	}
	if m.SpentMinerals != 0 {
		n += 5
	}
	if m.SpentVespene != 0 {
		n += 5
	}
	if m.FoodUsed != nil {
		l = m.FoodUsed.Size()
		n += 1 + l + sovScore(uint64(l))
	}
	if m.KilledMinerals != nil {
		l = m.KilledMinerals.Size()
		n += 1 + l + sovScore(uint64(l))
	}
	if m.KilledVespene != nil {
		l = m.KilledVespene.Size()
		n += 1 + l + sovScore(uint64(l))
	}
	if m.LostMinerals != nil {
		l = m.LostMinerals.Size()
		n += 2 + l + sovScore(uint64(l))
	}
	if m.LostVespene != nil {
		l = m.LostVespene.Size()
		n += 2 + l + sovScore(uint64(l))
	}
	if m.FriendlyFireMinerals != nil {
		l = m.FriendlyFireMinerals.Size()
		n += 2 + l + sovScore(uint64(l))
	}
	if m.FriendlyFireVespene != nil {
		l = m.FriendlyFireVespene.Size()
		n += 2 + l + sovScore(uint64(l))
	}
	if m.UsedMinerals != nil {
		l = m.UsedMinerals.Size()
		n += 2 + l + sovScore(uint64(l))
	}
	if m.UsedVespene != nil {
		l = m.UsedVespene.Size()
		n += 2 + l + sovScore(uint64(l))
	}
	if m.TotalUsedMinerals != nil {
		l = m.TotalUsedMinerals.Size()
		n += 2 + l + sovScore(uint64(l))
	}
	if m.TotalUsedVespene != nil {
		l = m.TotalUsedVespene.Size()
		n += 2 + l + sovScore(uint64(l))
	}
	if m.TotalDamageDealt != nil {
		l = m.TotalDamageDealt.Size()
		n += 2 + l + sovScore(uint64(l))
	}
	if m.TotalDamageTaken != nil {
		l = m.TotalDamageTaken.Size()
		n += 2 + l + sovScore(uint64(l))
	}
	if m.TotalHealed != nil {
		l = m.TotalHealed.Size()
		n += 2 + l + sovScore(uint64(l))
	}
	if m.CurrentApm != 0 {
		n += 6
	}
	if m.CurrentEffectiveApm != 0 {
		n += 6
	}
	return n
}

func sovScore(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozScore(x uint64) (n int) {
	return sovScore(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Score) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Score: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Score: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreType", wireType)
			}
			m.ScoreType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScoreType |= Score_ScoreType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScoreDetails == nil {
				m.ScoreDetails = &ScoreDetails{}
			}
			if err := m.ScoreDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CategoryScoreDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CategoryScoreDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CategoryScoreDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field None", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.None = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Army", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Army = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Economy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Economy = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Technology", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Technology = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upgrade", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Upgrade = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipScore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VitalScoreDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VitalScoreDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VitalScoreDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Life", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Life = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shields", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Shields = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipScore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScoreDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScoreDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScoreDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleProductionTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.IdleProductionTime = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleWorkerTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.IdleWorkerTime = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalValueUnits", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TotalValueUnits = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalValueStructures", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TotalValueStructures = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KilledValueUnits", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.KilledValueUnits = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KilledValueStructures", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.KilledValueStructures = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedMinerals", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CollectedMinerals = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedVespene", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CollectedVespene = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionRateMinerals", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CollectionRateMinerals = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionRateVespene", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CollectionRateVespene = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpentMinerals", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SpentMinerals = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpentVespene", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SpentVespene = float32(math.Float32frombits(v))
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoodUsed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FoodUsed == nil {
				m.FoodUsed = &CategoryScoreDetails{}
			}
			if err := m.FoodUsed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KilledMinerals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KilledMinerals == nil {
				m.KilledMinerals = &CategoryScoreDetails{}
			}
			if err := m.KilledMinerals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KilledVespene", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KilledVespene == nil {
				m.KilledVespene = &CategoryScoreDetails{}
			}
			if err := m.KilledVespene.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LostMinerals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LostMinerals == nil {
				m.LostMinerals = &CategoryScoreDetails{}
			}
			if err := m.LostMinerals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LostVespene", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LostVespene == nil {
				m.LostVespene = &CategoryScoreDetails{}
			}
			if err := m.LostVespene.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendlyFireMinerals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FriendlyFireMinerals == nil {
				m.FriendlyFireMinerals = &CategoryScoreDetails{}
			}
			if err := m.FriendlyFireMinerals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendlyFireVespene", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FriendlyFireVespene == nil {
				m.FriendlyFireVespene = &CategoryScoreDetails{}
			}
			if err := m.FriendlyFireVespene.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedMinerals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UsedMinerals == nil {
				m.UsedMinerals = &CategoryScoreDetails{}
			}
			if err := m.UsedMinerals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedVespene", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UsedVespene == nil {
				m.UsedVespene = &CategoryScoreDetails{}
			}
			if err := m.UsedVespene.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsedMinerals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalUsedMinerals == nil {
				m.TotalUsedMinerals = &CategoryScoreDetails{}
			}
			if err := m.TotalUsedMinerals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsedVespene", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalUsedVespene == nil {
				m.TotalUsedVespene = &CategoryScoreDetails{}
			}
			if err := m.TotalUsedVespene.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDamageDealt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalDamageDealt == nil {
				m.TotalDamageDealt = &VitalScoreDetails{}
			}
			if err := m.TotalDamageDealt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDamageTaken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalDamageTaken == nil {
				m.TotalDamageTaken = &VitalScoreDetails{}
			}
			if err := m.TotalDamageTaken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHealed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalHealed == nil {
				m.TotalHealed = &VitalScoreDetails{}
			}
			if err := m.TotalHealed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentApm", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CurrentApm = float32(math.Float32frombits(v))
		case 28:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentEffectiveApm", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CurrentEffectiveApm = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipScore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipScore(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowScore
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthScore
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupScore
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthScore
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthScore        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowScore          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupScore = fmt.Errorf("proto: unexpected end of group")
)
